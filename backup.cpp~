////////////////////////////////////////////////
//
//
//      CS 6378 - PROJECT 2
//    MUTUAL EXCLUSION QUORUM
//            SERVER
//
//
/////////////////////////////////////////////////
#include "connection.h"
using namespace std;
#define TRUE             1
#define FALSE            0
//global mutuex
pthread_mutex_t list_lock;
pthread_mutex_t resource_lock;
pthread_mutex_t LOCKED_lock;
pthread_mutex_t message_received_count_lock;
pthread_mutex_t message_sent_count_lock;
pthread_mutex_t exit_number_lock;
bool LOCKED=FALSE;
int message_sent_count=0;
int message_received_count=0;
int deadlock_count=0;
int exit_number=5;
priority_queue <string, vector<string> ,greater<string> > QUEUE;
bool terminate_socket=TRUE;
bool close_flag=TRUE;

//Function
//Grab the IP Address of the current machine
string getIPAddress()
{
    	string ipAddress="Unable to get IP Address";
    	struct ifaddrs *interfaces = NULL;
    	struct ifaddrs *temp_addr = NULL;
    	int success = 0;
    
    	success = getifaddrs(&interfaces);
    	if (success == 0) 
	{
        
        	temp_addr = interfaces;
        	while(temp_addr != NULL) 
		{
            		if(temp_addr->ifa_addr->sa_family == AF_INET) 
			{
                
                		if(strcmp(temp_addr->ifa_name, "en0"))
				{
                    			ipAddress=inet_ntoa(((struct sockaddr_in*)temp_addr->ifa_addr)->sin_addr);
                		}
            		}
            	temp_addr = temp_addr->ifa_next;
        	}
    	}
   
    	freeifaddrs(interfaces);
    	return ipAddress;
}
///Creating a class to deal with lower socket 
class Socket_connection
{
public:
	int socket_fd, new_socket, valread; 
	struct sockaddr_in address; 
	int opt = 1; 
	int addrlen = sizeof(address); 
	int iMode=0;
	Socket_connection()
	{
		// Creating socket file descriptor 
		if ((socket_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) 
		{ 
			perror("socket failed"); 
			exit(EXIT_FAILURE); 
		} 
		bzero((char *) &address, sizeof(address));
		ioctl(socket_fd, FIONBIO, &iMode); 
		address.sin_port = htons(PORT);
		address.sin_family = AF_INET;
		 
	}
	Socket_connection(const Socket_connection &sock)  //copy constructor
	{
		socket_fd=sock.socket_fd;
		new_socket=sock.new_socket; 
		valread=sock.valread;
		address=sock.address; 
		opt=1;
		addrlen =sock.addrlen;
		iMode=0;

	}
	~Socket_connection()  //destructor
	{
	
	}
	int connect_socket(char* IPname)
	{	
		
		
		if(inet_pton(AF_INET, IPname, &address.sin_addr)<=0)  
    		{ 
        		cout<<"Invalid address/ Address not supported "<<endl; 
        		return 0; 
    		}		
		
		if(connect(socket_fd, (struct sockaddr *)&address, sizeof(address))<0) 
		{
			cout<<"Connection Failed "<<endl; 
        		return 0;
		}
		else
		{
			return 1;
		}
		
		
		
    		
	}
	int listen_socket()
	{	
		
		// Forcefully attaching socket to the port 2408 
		if (setsockopt(socket_fd, SOL_SOCKET, (SO_REUSEPORT | SO_REUSEADDR),&opt, sizeof(opt))) 
		{ 
		perror("setsockopt"); 
		exit(EXIT_FAILURE); 
		} 
		address.sin_addr.s_addr = INADDR_ANY; 
		
		// Forcefully attaching socket to the port 8080 
		if (bind(socket_fd, (struct sockaddr *)&address, sizeof(address))<0) 
		{ 
		perror("bind failed"); 
		return 0; 
		} 
		
		if (listen(socket_fd, 32) < 0) 
		{ 
		perror("listen failed"); 
		return 0; 
		} 
		
	}
	int return_accept_response()
	{
		cout<<"waiting to connect here"<<endl;
		if ((new_socket = accept(socket_fd, (struct sockaddr *)&address,(socklen_t*)&addrlen))<0) 
		{ 
		perror("accept failed"); 
		return 0; 
		} 
		else
		{
			return 1;
		}
		
	}
	int return_accept_socket()
	{
		return new_socket;
	}
	
			
};

//Creating a wrapper for the socket with sender and receiver information
class SocketWrapper
{
public:
	string sender;
	string receiver;
	Socket_connection socket_id;
	int connect_num;
	SocketWrapper()
	{
		sender="";
		receiver="";

	}
	SocketWrapper(const SocketWrapper &wrap)//copy constructor
	{
		sender=wrap.sender;
		receiver=wrap.receiver;
		socket_id=wrap.socket_id;
		connect_num=wrap.connect_num;

	}
	~SocketWrapper()//destructor
	{
	}
	
};

///function
//to read all the files present in the directory
string read_directory(char* name)
{
		
	char files[200];
	DIR* dirp = opendir(name);
	list<string> filesList;
	struct dirent * dp;
	
	while ((dp = readdir(dirp)) != NULL) 
	{
	
		if(strcmp(dp->d_name,".")==0 || strcmp(dp->d_name,"..")==0 || string(dp->d_name).back()=='~')
			continue;
		
		filesList.push_back(dp->d_name);
		
	}
	closedir(dirp);
	filesList.sort();
	list<string>::iterator it2;

	
	for (it2 = filesList.begin(); it2 != filesList.end(); it2++)
	{  	
		strcat(files,(*it2).c_str());
		strncat(files,",",sizeof(","));
	}
	return string(files);
}
//find the server number
int findServerNum(string IP)
{
	char* serverIPList[8]={A,B,C,D,E,F,G,H};	
	int N=8; //Total number of Servers
	int server_num=10;
	for(int i=0;i<N;i++)// find the client number
	{
		if(IP==string(serverIPList[i]))
		{
			server_num=i;
			break;	
		}
	}
	return server_num;
}
//reading the phase of connection and disconnection
int readConfigure(int phase_num,int server_num,int makeConnect[8])
{
	char* serverIPList[8]={A,B,C,D,E,F,G,H};
	//int makeConnect[8]={-1,-1,-1,-1,-1,-1,-1,-1};
	std::ifstream f("Configure_Connection.txt");
	string s;
	string server_letter="ABCDEFGH";
	int flag=0;
	int end_file=0; 
	int count=0;
	list<int> fromConnect;
	for (int i = 1; i <= phase_num; i++)
	{	
		try
		{
        		std::getline(f, s);
		}
		catch(...)
		{
			return 1;
		}
	}
	cout<<s<<endl;
	for(int j=0;j<s.length();j++)
	{
		if(s[j]==':')
		{
			if(flag==1)
				break;
			else
			{
			 	fromConnect.clear();
			}
		}
		if(flag==1)
		{
			makeConnect[count]=1;
		}
		if(server_letter[server_num]==s[j])
		{
			flag=1;
		}
		else if(flag!=1)
		{
			fromConnect.push_back(j);
		}
		if(s[j]!=':')
		{
			count++;
		}
	}
	list<int>::iterator it;
	int l;
	for (l=0,it=fromConnect.begin(); it!=fromConnect.end(); ++it,l++)
	{
    		makeConnect[(*it)]=0;
	}
	return end_file;
}
//function to append the string to the file
void writeFile(char* filename,string appendText)
{

  	std::ofstream outfile;

  	outfile.open(filename, std::ios_base::app);
  	outfile << appendText<<endl;;


}
//function to get the last line from the file
string getLastLine(char* filename)
{
	std::string lastline;
	std::ifstream fs;
	fs.open(filename, std::fstream::in);
	if(fs.is_open())
	{
		//Got to the last character before EOF
		fs.seekg(-1, std::ios_base::end);
		if(fs.peek() == '\n')
		{
			//Start searching for \n occurrences
			fs.seekg(-1, std::ios_base::cur);
			int i = fs.tellg();
			for(i;i > 0; i--)
			{
				if(fs.peek() == '\n')
				{
 					 //Found
  					fs.get();
  					break;
				}		
				//Move one character back
				fs.seekg(i, std::ios_base::beg);
			}
		}

		getline(fs, lastline);
		std::cout << lastline << std::endl;
	}
	else
	{
		std::cout << "Could not find end line character" << std::endl;
		lastline="no content";
	}	
	return lastline;
}
//read thread struct
struct read_app
{
		//list <SocketWrapper> *SocketConnectionList;
		int socket_id;
		int connect_num;
};
void *readThreadFunction(void *threadarg)
{
	struct read_app *data;
	data = (struct read_app *) threadarg;
	char *close_msg="close";
	cout<<"Read Thread connected to SERVER"<<data->connect_num<<endl;
	while(1)
	{
		char buf[1024]={0};
		int valread1;
		valread1 = read(s1.socket_fd  , buf, 1024); 
		//cout<<string(buf)<<endl;
		if(valread1 && (strcmp(buf, "close") == 0))
		{
			break;
		}else if(valread1 && (strcmp(buf, "update") == 0))
		{

		}
	}
}

//listen thread Struct
struct listenThreadStruct
{
	list <SocketWrapper> *SocketConnectionList;
};

// this thread always listen in the port 2408 and updates the list
void *listenThread(void *threadarg)
{
	struct listenThreadStruct *data;
	data = (struct listenThreadStruct *) threadarg;
	cout<<"Listen Thread Started"<<endl;
	char *setup_msg = "received";
	while(terminate_socket)
	{
		Socket_connection s1;
		s1.listen_socket();
		while(1)
		{	
			int stat=s1.return_accept_response();
			if (stat==1) 
			{	
			
				send(s1.return_accept_socket(), setup_msg , strlen(setup_msg) , 0 ); 
				SocketWrapper w1;
				w1.sender=inet_ntoa(s1.address.sin_addr);
				w1.receiver=getIPAddress();
				w1.socket_id=s1;
				if(string(inet_ntoa(s1.address.sin_addr))==con)
				{
					w1.connect_num=10;
				}
				else
				{
					w1.connect_num=findServerNum(string(inet_ntoa(s1.address.sin_addr)));
				}
				//pthread_mutex_lock(&list_lock);
				(data->SocketConnectionList)->push_back(w1);
				//pthread_mutex_unlock(&list_lock);
				cout<<"Receiver - connected from SERVER "<<inet_ntoa(s1.address.sin_addr) <<" to SERVER "<<getIPAddress()<<endl;
									
			}
			else
			{	
				cout<<"couldnt connect to the socket-receiver side"<<endl;
		
			}
		
		
		}
		close_flag=TRUE;
	}


}



// Make connection.. Server waits to connect to all threads
int makeConnection(list <SocketWrapper> *SocketConnectionList)
{	
	cout<<"Main Client Thread created"<<endl;
	int phase=4;//number of stage... this has to be entered manually... it is the length of the configure file
	char* serverIPList[8]={A,B,C,D,E,F,G,H};
	int connection_start=0,status,client_num,flag=0;
	char *setup_msg = "received";
	//char *end_msg = "end_connect";
	//char *setup_msg = "start";
	char *close_msg ="close";
	
	int valread=0;
	//int received_pre_msg=0;
	int server_num;
	server_num=findServerNum(getIPAddress());
	cout<<"I am a Server no:"<<server_num <<" and My Ip address is::"<<getIPAddress()<<endl;
	//controller connection
	/*
	Socket_connection s1;
	s1.listen_socket();
	SocketWrapper Controller_wrapper;	
	int stat=s1.return_accept_response();
	if (stat==1) 
	{	
		
		send(s1.return_accept_socket(), setup_msg , strlen(setup_msg) , 0 ); 
		Controller_wrapper.sender=inet_ntoa(s1.address.sin_addr);
		Controller_wrapper.receiver=getIPAddress();
		Controller_wrapper.socket_id=s1;
		Controller_wrapper.connect_num=10;//connection number for controller//findServerNum(string(inet_ntoa(s1.address.sin_addr)));
		//pthread_mutex_lock(&list_lock);
		//(data->SocketConnectionList)->push_back(w1);
		//pthread_mutex_unlock(&list_lock);
		cout<<"Controller - connected from "<<inet_ntoa(s1.address.sin_addr) <<" to "<<getIPAddress()<<endl;
								
	}
	else
	{	
		cout<<"couldnt connect to the socket-receiver side"<<endl;
	
	}
	*/
	//creating the generic listen thread that listens in the PORT 2408 and push the socket to the List.
	pthread_t listen_application;
	struct listenThreadStruct l;
	l.SocketConnectionList=SocketConnectionList;
	int rc = pthread_create(&listen_application, NULL, listenThread, (void *)&l);
	if (rc)
	{
		cout<<"Problem with the creating listen thread.."<<endl;
		return 0;	
	}


	int phase_num=0;
	//while skipping cin
	int cin_fail;
	//cout<<"Enter 1 to chage the Phase of the Connection:";
	while(1)//for(int k=0;k<phase;k++)
	{

		string Phase_Shift;
		//cin>>Phase_Shift;
		//cin.clear();
		//cin.ignore(9999,'\n');
		//getline(cin,Phase_Shift);
		//cout<<Phase_Shift<<endl;
		cin_fail=0;
		/*
		if(cin.fail())
		{
			cin_fail=1;
			cin.clear();
			cin.ignore(1000,'\n');
		}
		*/
		char Controller_msg[1024]={0};
		list <SocketWrapper> :: iterator it1;
		
		for( it1 = SocketConnectionList->begin(); it1 != SocketConnectionList->end(); ++it1) 
		{
			if((*it1).connect_num==10)
			{
				valread = read((*it1).socket_id.return_accept_socket(), Controller_msg, 1024); 
				break;
			}
		}

		
		if(strcmp(Controller_msg,"phase")==0 && valread)
		{
			if(phase_num>5)// 5 is the number of lines in the configure text
			{	
				cout<<"Exiting beacuse configure file ended"<<endl;
				break;
			}
			int makeConnect[8]={-1,-1,-1,-1,-1,-1,-1,-1};
			phase_num=phase_num+1;
			int end_file=readConfigure(phase_num,server_num,makeConnect);
			if(end_file)
			{
				cout<<"File Ended"<<endl;
				break;
			}
			cout<<"Iteration "<<phase_num<<endl;
			for(int i=0;i<8;i++)
			{
				cout<<makeConnect[i];
			}
			for(int i=0;i<8;i++)
			{
				if(makeConnect[i]==-1)
				{
					list <SocketWrapper> :: iterator it;	
					for(it = SocketConnectionList->begin(); it != SocketConnectionList->end(); ++it) 
					{
						if((*it).connect_num==i)
						{
							if((*it).receiver==getIPAddress())
							{
								send((*it).socket_id.return_accept_socket(), close_msg , strlen(close_msg) , 0 ); 
								//close all the socket connection and pushing the node out of the list
								////shutdown((*it).socket_id.socket_fd,3);
								shutdown((*it).socket_id.return_accept_socket(),3);
								////close((*it).socket_id.socket_fd);
								//close_flag=FALSE;
								close((*it).socket_id.return_accept_socket());
							
							}
							else
							{
								send((*it).socket_id.socket_fd, close_msg , strlen(close_msg) , 0);
								shutdown((*it).socket_id.socket_fd,3);
								close((*it).socket_id.socket_fd);
							}		
							cout<<"removing the node SERVER "<< findServerNum((*it).sender)<<" connected to SERVER "<<findServerNum((*it).receiver)<<endl;
							it=SocketConnectionList->erase(it);
							break;
						}
			
					}
				}
			}
			cout<<endl;
			int skip;
			

			for(int i=0;i<8;i++)
			{
				skip=0;
				if(makeConnect[i]==1)
				{
					list <SocketWrapper> :: iterator itt;
					int l;
					for(l=0, itt = SocketConnectionList->begin(); itt != SocketConnectionList->end(); ++itt,l++) 
					{
						if((*itt).sender==string(serverIPList[i]) || (*itt).receiver==string(serverIPList[i]))
						{
							skip=1;
							break;
						}
					}
					if (skip==1)
					{
						continue;
					}
					
					Socket_connection s1; //created for the sender clients
					SocketWrapper w1;
					w1.sender=getIPAddress();
					w1.receiver=serverIPList[i];
					w1.connect_num=findServerNum(string(serverIPList[i]));
					//connecting other servers
					int stat=s1.connect_socket(serverIPList[i]);
					w1.socket_id=s1;
					if (stat==1)
					{	
						
						char buf[1024]={0};
						int valread1;
						valread1 = read(s1.socket_fd  , buf, 1024); 
						//cout<<string(buf)<<endl;
						if(valread1 && (strcmp(buf, "received") == 0))
						{
							//pthread_mutex_lock(&list_lock);
							SocketConnectionList->push_back(w1); //need mutex here
							//pthread_mutex_unlock(&list_lock);
							cout<<"Sender - connected "<< w1.sender <<" to "<< w1.receiver <<endl;
						}
					}
					else
					{
						cout<<"error in sending the client connect.."<<endl;
		
					}
					
				}
				
			}
		//pthread to readAll Socket list
		list <SocketWrapper> :: iterator iterator1;
		int s;
		for(s=0, iterator1 = SocketConnectionList->begin(); iterator1 != SocketConnectionList->end(); ++itt,s++) 
		{
			pthread_t readThreadApplication;
			struct read_app R;
			R.connect_num=(*iterator1).connect_num;
			if((*iterator1).sender==getIPAddress())
			{
				R.socket_id=(*iterator1).socket_id.socket_fd;
			}
			else
			{
				R.socket_id=(*iterator1).socket_id.return_accept_socket();
			}
			//R.SocketConnectionList=&SocketConnectionList;
			int rc = pthread_create(&readThreadApplication, NULL, readThreadFunction, (void *)&R);
			if (rc)
			{
				cout<<"Problem with the creating exit thread.."<<endl;
				return 0;	
			}
		}

		
		}
		else if(strcmp(Controller_msg,"write")==0 && valread)
		{
			cout<<"Initiate the Write Sequence"<<endl;
		}
		else if(strcmp(Controller_msg,"end")==0  && valread)
		{
			cout<<"End the Transactions"<<endl;
			break;
		}
		
		list <SocketWrapper> :: iterator it;
		for(it = SocketConnectionList->begin(); it != SocketConnectionList->end(); ++it) 
		{
			cout<<"SERVER "<<findServerNum((*it).sender)<<" connected to SERVER "<<findServerNum((*it).receiver)<<endl;
			
		}
		
		
	}	

/*
	if (server_num==1)
	{	
		cout<<"Enter 1 to setup server connection: ";
		cin>>connection_start;
		if (!(connection_start==1))
		{	
			cout<<"invalid parameter.. enter 1 to setup connection ..exiting...";
			return 0;
		}
		
	}
	else
	{
		Socket_connection s1;
		s1.listen_socket();
		int stat=s1.return_accept_response();
		send(s1.return_accept_socket(), setup_msg , strlen(setup_msg) , 0 ); 
		SocketWrapper w1;
		w1.sender=inet_ntoa(s1.address.sin_addr);
		w1.receiver=getIPAddress();
		w1.socket_id=s1;
		w1.connect_num=findServerNum(string(inet_ntoa(s1.address.sin_addr)));
		//pthread_mutex_lock(&list_lock);
		SocketConnectionListServer->push_back(w1);
		//pthread_mutex_unlock(&list_lock);
		cout<<"Receiver - connected from "<<inet_ntoa(s1.address.sin_addr) <<" to "<<getIPAddress()<<endl;
	}

	for(int i=0;i<5;i++)
	{
		
		Socket_connection s1; //created for the sender clients
		SocketWrapper w1;
		w1.sender=getIPAddress();
		w1.receiver=clientIPList[i];
		w1.connect_num=findClientNum(string(clientIPList[i]));
		//connecting the clients in mesh
		int stat=s1.connect_socket(clientIPList[i]);
		w1.socket_id=s1;
		if (stat==1)
		{	
			
			char buf[1024]={0};
			valread = read(s1.socket_fd  , buf, 1024); 
			if(valread && (strcmp(buf, "received") == 0))
			{
				pthread_mutex_lock(&list_lock);
				SocketConnectionList->push_back(w1); //need mutex here
				pthread_mutex_unlock(&list_lock);
				cout<<"Sender - connected "<< w1.sender <<" to "<< w1.receiver <<endl;
			}
		}
		else
		{
			cout<<"error in sending the client connect.."<<endl;
		
		}
		
	}
	for(int i=1;i<8;i++)
	{
		if (!(2 * server_num==i || (2 * server_num)+1==i))
			continue;
		Socket_connection s1; //created for the sender clients
		SocketWrapper w1;
		w1.sender=getIPAddress();
		w1.receiver=serverIPList[i-1];
		w1.connect_num=i-1;
		//connecting the clients in mesh
		int stat=s1.connect_socket(serverIPList[i-1]);
		w1.socket_id=s1;
		if (stat==1)
		{	
			
			char buf[1024]={0};
			valread = read(s1.socket_fd  , buf, 1024); 
			
			if(valread && (strcmp(buf, "received") == 0))
			{
				
				pthread_mutex_lock(&list_lock);
				SocketConnectionListServer->push_back(w1); //need mutex here
				pthread_mutex_unlock(&list_lock);
				cout<<"Sender - connected "<< w1.sender <<" to "<< w1.receiver <<endl;
			}
		}
		else
		{
			cout<<"error in sending the client connect.."<<endl;
		
		}
		

	}
*/
	cout<<"Connection completed"<<endl;	
}

/*
struct Reply_thread_data
{
	int socket;
	int client_num;
	int socket_list[5];
};
//Respond to the Client request of ENQUIRE,WRITE and READ
void *REPLY_CS(void *threadarg)
{
	struct Reply_thread_data *data;
	data = (struct Reply_thread_data *) threadarg;
	char finish_msg[100] ={0};
	char filesList[100]={0};
	
	while(1)
	{
		
		char buf[100]={0};
		
		int valread = read(data->socket, buf, 100); 
		
		string buffer(buf);
		
		size_t found0 = buffer.find("REQUEST");
		size_t found1 = buffer.find("RELEASE");
		size_t found2 = buffer.find("END");
		size_t found3 = buffer.find("start");
		//cout<<"Received message "<<buffer<<endl;
		pthread_mutex_lock(&message_received_count_lock);
		message_received_count++;
		pthread_mutex_unlock(&message_received_count_lock);
		std::string delimiter = ":";
		char time_content[100]={0};		
		if(valread && (found0 != string::npos))
		{	
			if(!LOCKED)
			{
				pthread_mutex_lock(&LOCKED_lock);
				LOCKED=TRUE;
				pthread_mutex_unlock(&LOCKED_lock);
				snprintf( filesList, sizeof(filesList), "%s", "GRANT");
				send(data->socket, filesList , strlen(filesList) , 0 );
				cout<<"Sending GRANT measage to CLIENT:"<<data->client_num<<endl;
				pthread_mutex_lock(&message_sent_count_lock);
				message_sent_count++;
				pthread_mutex_unlock(&message_sent_count_lock);
			}
			else
			{
				
				size_t pos = 0;
				std::string token;
				pos = buffer.find(":");
				token = buffer.substr(0, buffer.find(":"));
				buffer.erase(0, pos + delimiter.length());
				pos = buffer.find(":");
				token = buffer.substr(0, buffer.find(":"));
				
				snprintf( time_content, sizeof(time_content), "%s-%d", token.c_str(),data->client_num);
				QUEUE.push(time_content);
				cout<<"push request from CLIENT:"<<data->client_num<<" to QUEUE::content "<<time_content<<endl;
			}
			

		}
		else if(valread && (found1 != string::npos))
		{
			if(QUEUE.empty())
			{
				pthread_mutex_lock(&LOCKED_lock);
				LOCKED=FALSE;
				pthread_mutex_unlock(&LOCKED_lock);
				cout<<"queue is empty and not locked"<<endl;
			}
			else
			{
				
				string time_order;
				cout<<QUEUE.top()<<endl;;
				time_order=QUEUE.top();
				cout<<"POP out of the QUEUE:"<<time_order<<endl;
				QUEUE.pop();
				size_t pos = 0;
				std::string token;
				pos = time_order.find("-");
				token = time_order.substr(0, time_order.find("-"));
				time_order.erase(0, pos + delimiter.length());
				
				pos = time_order.find("-");
				token = time_order.substr(0, time_order.find("-"));
				
				snprintf( filesList, sizeof(filesList), "%s", "GRANT1");
				send(data->socket_list[stoi(token)-1], filesList , strlen(filesList) , 0 );
				cout<<"Sending GRANT message to CLIENT::"<<token<<endl;
				pthread_mutex_lock(&message_sent_count_lock);
				message_sent_count++;
				pthread_mutex_unlock(&message_sent_count_lock);
				
			}

		}
		else if(valread && (found2 != string::npos))
		{
			
			cout<<"Termination message reached from CLIENT"<<data->client_num<<endl;
			pthread_mutex_lock(&exit_number_lock);
			exit_number--;			
			pthread_mutex_unlock(&exit_number_lock);
			break;
		}else if(valread && (found3 != string::npos))
		{
			while( !QUEUE.empty() ) 
			{			
				QUEUE.pop();
			}
			LOCKED=FALSE;
			message_sent_count=0;
			message_received_count=0;
		}
		
	}

}

//Reply thread to handle all the transaction
int ReplyClient(list <SocketWrapper> *SocketConnectionList)
{
	
	pthread_t REPLY[5];
	struct Reply_thread_data Rep[5];
	int l;
	//int socket_list[6];
	list <SocketWrapper> :: iterator itt;
	for(int i=0;i<5;i++)
	{
		for(l=0, itt = SocketConnectionList->begin(); itt != SocketConnectionList->end(); ++itt,l++) 
		{
			Rep[i].socket_list[(*itt).connect_num-1]=((*itt).socket_id).socket_fd;
		}
	}
	for(l=0, itt = SocketConnectionList->begin(); itt != SocketConnectionList->end(); ++itt,l++) 
	{
		
		Rep[l].socket=((*itt).socket_id).socket_fd;
		Rep[l].client_num=(*itt).connect_num;
		
		int rc = pthread_create(&REPLY[l], NULL, REPLY_CS, (void *)&Rep[l]);
		if (rc)
		{
			cout<<"Problem with the creating Reply Thread.."<<endl;
			return 0;	
		}
	}
	

}
struct exit_app
{
	list <SocketWrapper> *SocketConnectionList;
	
};
//thread to close all the sockets and exit application 
void *exit_fn(void *threadarg)
{
	struct exit_app *data;
	data = (struct exit_app *) threadarg;
	int l;
	list <SocketWrapper> :: iterator itt;
	int flag=0;
	while(1)
	{
		if(exit_number==0 && flag==0)
		{	
			if (getIPAddress()==A)
			{
				for(l=0, itt = (data->SocketConnectionList)->begin(); itt != (data->SocketConnectionList)->end(); ++itt,l++) 
				{ 
					char exit[100]={0};
					snprintf( exit, sizeof(exit), "%s", "END");
					send(((*itt).socket_id).socket_fd,&exit , strlen(exit) , 0);	
					cout<<"Sent END message to "<<(*itt).receiver<<endl;

				}
			}
			flag=1;
			exit_number--;
			sleep(3);
		}
		if(exit_number==-1)
		{
			cout<<"MESSAGE TRANSACTION STATS:"<<endl;
			cout<<"**************************"<<endl;
			cout<<"Total Number of Message Sent    ::"<<message_sent_count<<endl;
			cout<<"Total Number of Message Received::"<<message_received_count<<endl<<endl;
			
			for(itt = (data->SocketConnectionList)->begin(); itt != (data->SocketConnectionList)->end(); ++itt) 
			{
				close(((*itt).socket_id).socket_fd);
				close(((*itt).socket_id).new_socket);
			}
		
			cout<<"SYSTEM EXIT"<<endl;
			exit(0);// force all thread to exit
		}
	}	
}

struct restart_app
{
	list <SocketWrapper> *SocketConnectionList;
	
};
//thread to close all the sockets and exit application 
void *restart_fn(void *threadarg)
{
	struct exit_app *data;
	data = (struct exit_app *) threadarg;
	int l;
	list <SocketWrapper> :: iterator itt;
	char finish_msg[100]={0};
	string restart_msg;
	if (getIPAddress()==A)
	{
		while(1)
		{
			cout<<"Type \"start\" to start the transaction"<<endl;
			cin>>restart_msg;
			
			if(restart_msg=="start")
			{
			
				cout<<"******START QUORUM TRANSCATION********"<<endl;
				for(itt = (data->SocketConnectionList)->begin(); itt != (data->SocketConnectionList)->end(); ++itt) 
				{
					snprintf( finish_msg, sizeof(finish_msg), "%s", "start");
					send(((*itt).socket_id).socket_fd, &finish_msg , strlen(finish_msg) , 0 );
				}
		
		
			}
			else
			{
				cout<<"Not a Valid start message"<<endl;
			}
		}
	}
}

*/



//Main Function
int main()
{	
	list <SocketWrapper> SocketConnectionList;
	//list <SocketWrapper> SocketConnectionListServer;
	int status=makeConnection(&SocketConnectionList);
	if(status==0)
	{
		cout<<"Problem with connection/disconnection setup.."<<endl;
		return 1;	
	}
	/*
	pthread_t restart_application;
	struct restart_app r;
	r.SocketConnectionList=&SocketConnectionList;
	int res = pthread_create(&restart_application, NULL, restart_fn, (void *)&r);
	if (res)
	{
		cout<<"Problem with the creating Restart Thread.."<<endl;
		return 0;	
	}
	pthread_t exit_application;
	struct exit_app e;
	e.SocketConnectionList=&SocketConnectionList;
	int rc = pthread_create(&exit_application, NULL, exit_fn, (void *)&e);
	if (rc)
	{
		cout<<"Problem with the creating exit thread.."<<endl;
		return 0;	
	}
	int stat=ReplyClient(&SocketConnectionList);
	if(stat==0)
	{
		cout<<"Problem with Reply thread Connection"<<endl;
		return 1;	
	}
	*/
	cout<<"Back to Main Connection"<<endl;
	while(1)
	{
	}
		
	return 0;
}



///////controller

////////////////////////////////////////////////
//
//
//      CS 6378 - PROJECT 2
//      MUTUAL EXCLUSION - QUORUM
//            Controller
//
//
/////////////////////////////////////////////////
#include "connection.h"

using namespace std;

#define TRUE             1
#define FALSE            0
typedef int64_t msec_t;
//Global mutex for receiving threads
pthread_mutex_t list_lock;
pthread_mutex_t server_list_lock;
pthread_mutex_t struct_lock;
pthread_mutex_t Id_thread_lock;
pthread_mutex_t expected_grant_lock;
pthread_mutex_t message_received_count_lock;
pthread_mutex_t message_sent_count_lock;
//Global variable for thread control
int Id_thread=0;
int connect_complete=0; 
int expected_grant=4;
int start_transaction=0;
int unit_delay=100000;//100 miliseconds
int message_sent_count=0;
int message_received_count=0;
int deadlock_count=-1;
bool exit_number=0;
pthread_t start_Quorum[30];
//Grab the IP Address of the current machine
string getIPAddress()
{
    	string ipAddress="Unable to get IP Address";
    	struct ifaddrs *interfaces = NULL;
    	struct ifaddrs *temp_addr = NULL;
    	int success = 0;
    
    	success = getifaddrs(&interfaces);
    	if (success == 0) 
	{
        
        	temp_addr = interfaces;
        	while(temp_addr != NULL) 
		{
            		if(temp_addr->ifa_addr->sa_family == AF_INET) 
			{
                
                		if(strcmp(temp_addr->ifa_name, "en0"))
				{
                    			ipAddress=inet_ntoa(((struct sockaddr_in*)temp_addr->ifa_addr)->sin_addr);
                		}
            		}
            	temp_addr = temp_addr->ifa_next;
        	}
    	}
   
    	freeifaddrs(interfaces);
    	return ipAddress;
}

msec_t time_ms(void)
{
    struct timeval tv;
    gettimeofday(&tv, NULL);
    return (msec_t)tv.tv_sec * 1000 + tv.tv_usec / 1000;
}
///Creating a class to deal with lower socket 
class Socket_connection
{
public:
	int socket_fd, new_socket, valread; 
	struct sockaddr_in address; 
	int opt = 1; 
	int addrlen = sizeof(address); 
	int iMode=0;
	Socket_connection()
	{
		// Creating socket file descriptor 
		if ((socket_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) 
		{ 
			perror("socket failed"); 
			exit(EXIT_FAILURE); 
		} 
		bzero((char *) &address, sizeof(address));
		ioctl(socket_fd, FIONBIO, &iMode); 
		address.sin_port = htons( PORT );
		address.sin_family = AF_INET;
		 
	}
	Socket_connection(const Socket_connection &sock)  //copy constructor
	{
	socket_fd=sock.socket_fd;
	new_socket=sock.new_socket; 
	valread=sock.valread;
	address=sock.address; 
	opt=1;
	addrlen =sock.addrlen;
	iMode=0;

	}
	~Socket_connection()  //destructor
	{
	
	}
	int connect_socket(char* IPname)
	{	
		
		
		if(inet_pton(AF_INET, IPname, &address.sin_addr)<=0)  
    		{ 
        		cout<<"Invalid address/ Address not supported "<<endl; 
        		return 0; 
    		}		
		
		if(connect(socket_fd, (struct sockaddr *)&address, sizeof(address))<0) 
		{
			cout<<"Connection Failed "<<endl; 
        		return 0;
		}
		else
		{
			return 1;
		}
		
		
		
    		
	}
	int listen_socket()
	{	
		
		// Forcefully attaching socket to the port 2408 
		if (setsockopt(socket_fd, SOL_SOCKET, (SO_REUSEPORT | SO_REUSEADDR),&opt, sizeof(opt))) 
		{ 
		perror("setsockopt"); 
		exit(EXIT_FAILURE); 
		} 
		address.sin_addr.s_addr = INADDR_ANY; 
		
		// Forcefully attaching socket to the port 8080 
		if (bind(socket_fd, (struct sockaddr *)&address, sizeof(address))<0) 
		{ 
		perror("bind failed"); 
		return 0; 
		} 
		
		if (listen(socket_fd, 32) < 0) 
		{ 
		perror("listen failed"); 
		return 0; 
		} 
		
	}
	int return_accept_response()
	{
		
		if ((new_socket = accept(socket_fd, (struct sockaddr *)&address,(socklen_t*)&addrlen))<0) 
		{ 
		perror("accept failed"); 
		return 0; 
		} 
		else
		{
			return 1;
		}
		
	}
	int return_accept_socket()
	{
		return new_socket;
	}
	
			
};

//Creating a wrapper for the socket with sender and receiver information
class SocketWrapper
{
public:
	string sender;
	string receiver;
	Socket_connection socket_id;
	int connect_num;
	SocketWrapper()
	{
		sender="";
		receiver="";

	}
	SocketWrapper(const SocketWrapper &wrap)//copy constructor
	{
		sender=wrap.sender;
		receiver=wrap.receiver;
		socket_id=wrap.socket_id;
		connect_num=wrap.connect_num;

	}
	~SocketWrapper()//destructor
	{
	}
	
};
/*
////Struct to pass multiple parameter for all threads
struct Request_thread_data
{
	int client_num;
	int *Seq_num;
	int socket;
	int resource_num;

};
struct Reply_thread_data_array
{
	struct Reply_thread_data *Reply;
};
struct Reply_thread_data
{
	int client_num;
	int Seq_num=0;
	int Highest_Seq_num;
	bool Reply_Deferred[5];
	bool Using;
	bool Waiting;
	bool A[5];
	int socket[5];

};
struct Client_send_data
{
	int client_num;
	list <SocketWrapper> *SocketConnectionList;
	list <SocketWrapper> *SocketConnectionListServer;
	int over_ride;

};
*/
//find the server number
int findServerNum(string IP)
{
	char* serverIPList[8]={A,B,C,D,E,F,G,H};	
	int N=8; //Total number of Clients
	int server_num=0;
	for(int i=0;i<N;i++)// find the client number
	{
		if(IP==string(serverIPList[i]))
		{
			server_num=i;
			break;	
		}
	}
	return server_num;
}
/*
//Function returns the current client number with the ip passed as parameter
int findClientNum(string IP)
{
	char* clientIPList[5]={CLIENT1,CLIENT2,CLIENT3,CLIENT4,CLIENT5};
	
	int N=5; //Total number of Clients
	int client_num=0;
	for(int i=0;i<N;i++)// find the client number
	{
		if(IP==string(clientIPList[i]))
		{
			client_num=i;
			break;	
		}
	}
	return client_num+1; //the clients are addressed from 1-5
}

//function to append the string to the file
void writeFile(msec_t now)
{
	char* clientIPList[5]={CLIENT1,CLIENT2,CLIENT3,CLIENT4,CLIENT5};
	// current date/time based on current system
	msec_t t2=time_ms();
  	std::ofstream outfile;
	msec_t dif=(t2-now);
	
	
	char time_val[100]={0};
	snprintf( time_val, sizeof(time_val), "%lu", now);
	char diff_val[100]={0};
	snprintf( diff_val, sizeof(diff_val), "%lu", dif);
	
  	outfile.open("/home/012/j/jx/jxb162030/Desktop/aos_Project_2/file1.txt", std::ios_base::app);
  	outfile <<"Time: " <<time_val<<" wrote by CLIENT"<<findClientNum(getIPAddress())<<" ::"<<clientIPList[findClientNum(getIPAddress())-1]<<" and The Time elapsed for this Quorum transaction::"<<diff_val<<endl;


}
*/
//Main function to trigger connection to other clients and Servers in thread
int makeConnection(list <SocketWrapper> *SocketConnectionListServer)
{	
	cout<<"Main Client Thread created"<<endl;
	int value;
	char* serverIPList[8]={A,B,C,D,E,F,G,H};
	int valread;
	int connection_start=0,status,client_num,flag=0,rc;
	char *setup_msg = "received";
	cout<<"I am an server controller and My Ip address is::"<<getIPAddress()<<endl;
	cout<<"Type 1 to start connection:"<<endl;	
	cin>>value;
	while(1)
	{
		if(value==1)
		{
			for(int i=0;i<8;i++)
			{
				Socket_connection s1; //created for the sender clients
				SocketWrapper w1;
				w1.sender=getIPAddress();
				w1.receiver=serverIPList[i];
				w1.connect_num=findServerNum(string(serverIPList[i]));
				//connecting other servers
				int stat=s1.connect_socket(serverIPList[i]);
				w1.socket_id=s1;
				if (stat==1)
				{	

					char buf[1024]={0};
					valread = read(s1.socket_fd  , buf, 1024); 
					if(valread && (strcmp(buf, "received") == 0))
					{
						pthread_mutex_lock(&list_lock);
						SocketConnectionListServer->push_back(w1); //need mutex here
						pthread_mutex_unlock(&list_lock);
						cout<<"Sender - connected "<< w1.sender <<" to "<< w1.receiver <<endl;
					}
				}
				else
				{
					cout<<"error in sending the client connect.."<<endl;

				}
			}
			break;
		}
		else
		{
			cout<<"Please Enter 1 to start connection"<<endl;
		}
	}
	/*
	Socket_connection s1;
	s1.listen_socket();
	while(!(connection_start==1))
	{	
		
		int stat=s1.return_accept_response();
		
		if (stat==1) 
		{	
			
						
			send(s1.return_accept_socket(), setup_msg , strlen(setup_msg) , 0 ); 

			SocketWrapper w1;
			w1.sender=inet_ntoa(s1.address.sin_addr);
			w1.receiver=getIPAddress();
			w1.socket_id=s1;
			w1.connect_num=findServerNum(string(inet_ntoa(s1.address.sin_addr)));
			pthread_mutex_lock(&list_lock);
			SocketConnectionListServer->push_back(w1);
			pthread_mutex_unlock(&list_lock);
			cout<<"Receiver - connected from "<<inet_ntoa(s1.address.sin_addr) <<" to "<<getIPAddress()<<endl;
			
			if (SocketConnectionListServer->size()==7)
				connection_start=1;
									
		}
		else
		{	
			cout<<"couldnt connect to the socket-receiver side"<<endl;
		
		}
		
		
	}
	*/	
	cout<<"************Connection completed*************"<<endl;	
	return 1;	

	
}
/*
//struct for exit
struct exit_app
{

	list <SocketWrapper> *SocketConnectionListServer;
};
//thread to close all the sockets and exit application 
void *exit_fn(void *threadarg)
{
	struct exit_app *data;
	data = (struct exit_app *) threadarg;
	int l;
	
	list <SocketWrapper> :: iterator itt;
	while(1)
	{
		if(exit_number)
		{
		
			cout<<"MESSAGE TRANSACTION STATS:"<<endl;
			cout<<"**************************"<<endl;
			cout<<"Total Number of Message Sent    ::"<<message_sent_count<<endl;
			cout<<"Total Number of Message Received::"<<message_received_count<<endl;
			cout<<"Number of Deadlock              ::"<<deadlock_count<<endl<<endl;		
			for(itt = (data->SocketConnectionListServer)->begin(); itt != (data->SocketConnectionListServer)->end(); ++itt) 
			{
				close(((*itt).socket_id).socket_fd);
				close(((*itt).socket_id).new_socket);
			}
			cout<<"SYSTEM EXIT"<<endl;
			exit(0);// force all thread to exit
		}
	}
}
//Algorithm to grant reply to this transaction
struct grant
{
	int socket;
	string serverName;
};
void *grantReply(void *threadarg)
{
	struct grant *data;
	data = (struct grant *) threadarg;	
	int valread;
	char buf[1024]={0};
	while(1)
	{
		valread = read(data->socket, buf, 1024); 
		string buffer(buf);
		pthread_mutex_lock(&message_received_count_lock);
		message_received_count++;
		pthread_mutex_unlock(&message_received_count_lock);
		size_t found0 = buffer.find("GRANT");
		size_t found1 = buffer.find("END");
		size_t found2 = buffer.find("start");
		if(valread && (found0 != string::npos))
		{				
			pthread_mutex_lock(&expected_grant_lock);
			expected_grant=expected_grant-1;
			pthread_mutex_unlock(&expected_grant_lock);
			cout<<"GRANT received from SERVER"<<findServerNum(data->serverName)<<" receive grant count "<<expected_grant<<endl;
		}
		else if(valread && (found1 != string::npos))
		{
			exit_number=1;
		}
		else if(valread && (found2 != string::npos))
		{
			start_transaction=1;
			cout<<"START message received"<<endl;
		}
		else
		{
			
			cout<<"received a junk message :"<<string(buf)<<" from SERVER"<<findServerNum(data->serverName)<<endl;
		}
	}

}
struct askQuorum
{
	int socket;
	string serverName;
	msec_t time;
};
void *askQuorumServer(void *threadarg)
{
	struct askQuorum *data;
	data = (struct askQuorum *) threadarg;
	char request[100]={0};
	int valread;
	snprintf( request, sizeof(request), "%s:%lu", "REQUEST",data->time);
	send(data->socket,&request , strlen(request) , 0);
	cout<<"REQUEST sent to SERVER "<<findServerNum(data->serverName)<<endl;
	pthread_mutex_lock(&message_sent_count_lock);
	message_sent_count++;
	pthread_mutex_unlock(&message_sent_count_lock);
}

struct Quorum_app
{
	list <SocketWrapper> *SocketConnectionListServer;
};
void *Quorum_transaction(void *threadarg)
{
	struct Quorum_app *data;
	data = (struct Quorum_app *) threadarg;
	cout<<"******START QUORUM TRANSCATION********"<<endl;
	list <SocketWrapper> :: iterator itt;
	//binary tree quorum
	int Quorum_array[15][4]=
	{
	{1,2,4,-1},
	{1,2,5,-1},
	{1,4,5,-1},
	{1,3,6,-1},
	{1,3,7,-1},
	{1,6,7,-1},	
	{2,4,3,6},
	{2,4,3,7},
	{2,5,3,6},
	{2,5,3,7},
	{2,4,6,7},
	{2,5,6,7},
	{4,5,3,6},
	{4,5,3,7},
	{4,5,6,7}
	};
	int select_Quorum;
	char finish_msg[100]={0};
	for(itt = (data->SocketConnectionListServer)->begin(); itt != (data->SocketConnectionListServer)->end(); ++itt) 
	{
		snprintf( finish_msg, sizeof(finish_msg), "%s", "start");
		send(((*itt).socket_id).return_accept_socket(), &finish_msg , strlen(finish_msg) , 0 );
	}
	
	for(int i=0;i<20;i++)
	{
		int sleep_time=rand()%5+5;
		cout<<"****************************************************"<<endl;
		cout<<"My Sleep time is "<<sleep_time<<" unit of time -iteration#"<<i+1<<endl;
		usleep(sleep_time*unit_delay);
		

		select_Quorum=rand()%15;
		if(select_Quorum<6)
		{
			expected_grant=3;
			cout<<"The chosen Quorum are:"<<Quorum_array[select_Quorum][0]<<Quorum_array[select_Quorum][1]<<Quorum_array[select_Quorum][2]<<endl;
		}
		else
		{
			expected_grant=4;
			cout<<"The chosen Quorum are:"<<Quorum_array[select_Quorum][0]<<Quorum_array[select_Quorum][1]<<Quorum_array[select_Quorum][2]<<Quorum_array[select_Quorum][3]<<endl;
		}
		msec_t now=time_ms();//take the first snapshot time
		pthread_t Request[4];
		struct askQuorum REQ[4];
		for(int j=0;j<4;j++)
		{
			if(Quorum_array[select_Quorum][j]==-1)
				continue;

			for(itt = (data->SocketConnectionListServer)->begin(); itt != (data->SocketConnectionListServer)->end(); ++itt) 
			{
				
				if(Quorum_array[select_Quorum][j]==(*itt).connect_num)
				{
					
					REQ[j].serverName=(*itt).sender;
					REQ[j].socket=((*itt).socket_id).return_accept_socket();
					REQ[j].time=now;
					int rc = pthread_create(&Request[j], NULL, askQuorumServer, (void *)&REQ[j]);
					if (rc)
					{
						cout<<"Problem with the creating Reply Thread.."<<endl;
							
					}
					break;
				}
			}
		
		}
		cout<<"waiting for all grant from Server Quorums"<<endl;
		while(expected_grant)
		{
			if(start_transaction)
			{
				cout<<"thread exit"<<endl;
				pthread_exit(0);
				break;		
			}		
		}
	
		cout<<"Entering the CRITICAL SECTION"<<endl;
		writeFile(now);
		usleep(3*unit_delay);//unit of time
		cout<<"Exiting CRITICAL SECTION"<<endl;
		for(int j=0;j<4;j++)
		{
			if(Quorum_array[select_Quorum][j]==-1)
				continue;

			for(itt = (data->SocketConnectionListServer)->begin(); itt != (data->SocketConnectionListServer)->end(); ++itt) 
			{
				if(Quorum_array[select_Quorum][j]==(*itt).connect_num)
				{
					char release[100]={0};
					snprintf( release, sizeof(release), "%s:%d", "RELEASE",Quorum_array[select_Quorum][j]);
					send(((*itt).socket_id).return_accept_socket(),&release , strlen(release) , 0);
					cout<<"RELEASE sent to SERVER"<<findServerNum((*itt).sender)<<endl;
					pthread_mutex_lock(&message_received_count_lock);
					message_sent_count++;
					pthread_mutex_unlock(&message_received_count_lock);
										
				}
			}
		
		}
	
	}
	for(itt = (data->SocketConnectionListServer)->begin(); itt != (data->SocketConnectionListServer)->end(); ++itt) 
	{
		char exit[100]={0};
		snprintf( exit, sizeof(exit), "%s", "END");
		send(((*itt).socket_id).return_accept_socket(),&exit , strlen(exit) , 0);
	}
	

}
int connectQuorum(list <SocketWrapper> *SocketConnectionListServer)
{
	list <SocketWrapper> :: iterator itt;
	 
	int server1_socket;
	int valread;
	pthread_t grant_reply[7];
	struct grant GRANT[7];
	int m;
	for(m=0,itt = SocketConnectionListServer->begin(); itt != SocketConnectionListServer->end(); ++itt,m++) 
	{
		GRANT[m].socket=((*itt).socket_id).return_accept_socket();
		GRANT[m].serverName=(*itt).sender;
		int rc = pthread_create(&grant_reply[m], NULL, grantReply, (void *)&GRANT[m]);
		if (rc)
		{
			cout<<"Problem with the creating Reply Thread.."<<endl;
		
		}
	}
	
	while(1)
	{
		if(start_transaction==1)
		{
			usleep(1000000);
			start_transaction=0;
			usleep(1000000);
			message_sent_count=0;
			message_received_count=0;
			if(deadlock_count>=0)
			{
				pthread_cancel(start_Quorum[deadlock_count]);
				cout<<"Force exiting the previous thread."<<endl;
			}
			deadlock_count++;
			expected_grant=4;
			
			struct Quorum_app q;
			q.SocketConnectionListServer=SocketConnectionListServer;
			int rc = pthread_create(&start_Quorum[deadlock_count], NULL, Quorum_transaction, (void *)&q);
			if (rc)
			{
				cout<<"Problem with the creating Reply Thread.."<<endl;
				return 0;	
			}
		}else if(start_transaction==-1)
		{
			break;
		}
	}
	
	while(1)
	{
	}
	

}
*/
int sendMessage(list <SocketWrapper> *SocketConnectionListServer)
{
	string Message="";
	while(1)
	{
		cout<<"Type the Message to broadcast to Server:"<<endl;
		cin>>Message;
		if(strcmp(Message.c_str(),"phase")==0)
		{
			list <SocketWrapper> :: iterator itt;
			for(itt = SocketConnectionListServer->begin(); itt != SocketConnectionListServer->end(); ++itt) 
			{
				char phase_msg[100]={0};
				snprintf(phase_msg, sizeof(phase_msg), "%s", Message.c_str());
				send(((*itt).socket_id).socket_fd, &phase_msg , strlen(phase_msg) , 0 );
			}
		}
		else if(strcmp(Message.c_str(),"write")==0)
		{
			int server_num;
			cout<<"Enter the Server number to send write:"<<endl;
			// send to the specific server
			cin>>server_num;
			cout<<"sending write message to server"<<endl;
		}
		else if(strcmp(Message.c_str(),"end")==0)
		{
			break; // need to send termination message.
		}
	}

}
///MAIN FUNCTION
int main()
{	
	
	//char* serverIPList[7]={SERVER1,SERVER2,SERVER3,SERVER4,SERVER5,SERVER6,SERVER7};
	//int N=5; //Total number of Clients
	//int client_num;
	//srand (time(NULL));
	//client_num=findClientNum(getIPAddress());
	list <SocketWrapper> SocketConnectionListServer;
	int status=makeConnection(&SocketConnectionListServer);
	if (status==0)
	{
		cout<<"problem with the connection"<<endl;
		return 0;
	}
	int stat=sendMessage(&SocketConnectionListServer);
	if (stat==0)
	{
		cout<<"problem with the sending connection"<<endl;
		return 0;
	}
	/*
	pthread_t exit_application;
	struct exit_app e;
	e.SocketConnectionListServer=&SocketConnectionListServer;
	int rc = pthread_create(&exit_application, NULL, exit_fn, (void *)&e);
	if (rc)
	{
		cout<<"Problem with the creating Reply Thread.."<<endl;
		return 0;	
	}
	
	
	int res=connectQuorum(&SocketConnectionListServer);
	if(res)
	{
		cout<<"problem with the server connection"<<endl;
		return 0;
	}
	*/	
	return 0;
}


////////////server
////////////////////////////////////////////////
//
//
//      CS 6378 - PROJECT 2
//    MUTUAL EXCLUSION QUORUM
//            SERVER
//
//
/////////////////////////////////////////////////
#include "connection.h"
using namespace std;
#define TRUE             1
#define FALSE            0
//global mutuex
pthread_mutex_t list_lock;
pthread_mutex_t resource_lock;
pthread_mutex_t LOCKED_lock;
pthread_mutex_t message_received_count_lock;
pthread_mutex_t message_sent_count_lock;
pthread_mutex_t exit_number_lock;
bool LOCKED=FALSE;
int message_sent_count=0;
int message_received_count=0;
int deadlock_count=0;
int exit_number=5;
priority_queue <string, vector<string> ,greater<string> > QUEUE;
bool terminate_socket=TRUE;
bool close_flag=TRUE;
int VN=1;
int RU=8;
char DS='A';
bool LOCK_REQUEST=FALSE;
int M=0;
int waiting_reply=0;
bool Update_Success=FALSE;
bool Update_Flag=TRUE;
//Function
//Grab the IP Address of the current machine
string getIPAddress()
{
    	string ipAddress="Unable to get IP Address";
    	struct ifaddrs *interfaces = NULL;
    	struct ifaddrs *temp_addr = NULL;
    	int success = 0;
    
    	success = getifaddrs(&interfaces);
    	if (success == 0) 
	{
        
        	temp_addr = interfaces;
        	while(temp_addr != NULL) 
		{
            		if(temp_addr->ifa_addr->sa_family == AF_INET) 
			{
                
                		if(strcmp(temp_addr->ifa_name, "en0"))
				{
                    			ipAddress=inet_ntoa(((struct sockaddr_in*)temp_addr->ifa_addr)->sin_addr);
                		}
            		}
            	temp_addr = temp_addr->ifa_next;
        	}
    	}
   
    	freeifaddrs(interfaces);
    	return ipAddress;
}
///Creating a class to deal with lower socket 
class Socket_connection
{
public:
	int socket_fd, new_socket, valread; 
	struct sockaddr_in address; 
	int opt = 1; 
	int addrlen = sizeof(address); 
	int iMode=0;
	Socket_connection()
	{
		// Creating socket file descriptor 
		if ((socket_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) 
		{ 
			perror("socket failed"); 
			exit(EXIT_FAILURE); 
		} 
		bzero((char *) &address, sizeof(address));
		ioctl(socket_fd, FIONBIO, &iMode); 
		address.sin_port = htons(PORT);
		address.sin_family = AF_INET;
		 
	}
	Socket_connection(const Socket_connection &sock)  //copy constructor
	{
		socket_fd=sock.socket_fd;
		new_socket=sock.new_socket; 
		valread=sock.valread;
		address=sock.address; 
		opt=1;
		addrlen =sock.addrlen;
		iMode=0;

	}
	~Socket_connection()  //destructor
	{
	
	}
	int connect_socket(char* IPname)
	{	
		
		
		if(inet_pton(AF_INET, IPname, &address.sin_addr)<=0)  
    		{ 
        		cout<<"Invalid address/ Address not supported "<<endl; 
        		return 0; 
    		}		
		
		if(connect(socket_fd, (struct sockaddr *)&address, sizeof(address))<0) 
		{
			cout<<"Connection Failed "<<endl; 
        		return 0;
		}
		else
		{
			return 1;
		}
		
		
		
    		
	}
	int listen_socket()
	{	
		
		// Forcefully attaching socket to the port 2408 
		if (setsockopt(socket_fd, SOL_SOCKET, (SO_REUSEPORT | SO_REUSEADDR),&opt, sizeof(opt))) 
		{ 
		perror("setsockopt"); 
		exit(EXIT_FAILURE); 
		} 
		address.sin_addr.s_addr = INADDR_ANY; 
		
		// Forcefully attaching socket to the port 8080 
		if (bind(socket_fd, (struct sockaddr *)&address, sizeof(address))<0) 
		{ 
		perror("bind failed"); 
		return 0; 
		} 
		
		if (listen(socket_fd, 32) < 0) 
		{ 
		perror("listen failed"); 
		return 0; 
		} 
		
	}
	int return_accept_response()
	{
		cout<<"waiting to connect here"<<endl;
		if ((new_socket = accept(socket_fd, (struct sockaddr *)&address,(socklen_t*)&addrlen))<0) 
		{ 
		perror("accept failed"); 
		return 0; 
		} 
		else
		{
			return 1;
		}
		
	}
	int return_accept_socket()
	{
		return new_socket;
	}
	
			
};

//Creating a wrapper for the socket with sender and receiver information
class SocketWrapper
{
public:
	string sender;
	string receiver;
	Socket_connection socket_id;
	int connect_num;
	SocketWrapper()
	{
		sender="";
		receiver="";

	}
	SocketWrapper(const SocketWrapper &wrap)//copy constructor
	{
		sender=wrap.sender;
		receiver=wrap.receiver;
		socket_id=wrap.socket_id;
		connect_num=wrap.connect_num;

	}
	~SocketWrapper()//destructor
	{
	}
	
};

///function
//to read all the files present in the directory
string read_directory(char* name)
{
		
	char files[200];
	DIR* dirp = opendir(name);
	list<string> filesList;
	struct dirent * dp;
	
	while ((dp = readdir(dirp)) != NULL) 
	{
	
		if(strcmp(dp->d_name,".")==0 || strcmp(dp->d_name,"..")==0 || string(dp->d_name).back()=='~')
			continue;
		
		filesList.push_back(dp->d_name);
		
	}
	closedir(dirp);
	filesList.sort();
	list<string>::iterator it2;

	
	for (it2 = filesList.begin(); it2 != filesList.end(); it2++)
	{  	
		strcat(files,(*it2).c_str());
		strncat(files,",",sizeof(","));
	}
	return string(files);
}
//find the server number
int findServerNum(string IP)
{
	char* serverIPList[8]={A,B,C,D,E,F,G,H};	
	int N=8; //Total number of Servers
	int server_num=10;
	for(int i=0;i<N;i++)// find the client number
	{
		if(IP==string(serverIPList[i]))
		{
			server_num=i;
			break;	
		}
	}
	return server_num;
}
/*
//reading the phase of connection and disconnection
int readConfigure(int phase_num,int server_num,int makeConnect[8])
{
	char* serverIPList[8]={A,B,C,D,E,F,G,H};
	//int makeConnect[8]={-1,-1,-1,-1,-1,-1,-1,-1};
	std::ifstream f("Configure_Connection.txt");
	string s;
	string server_letter="ABCDEFGH";
	int flag=0;
	int end_file=0; 
	int count=0;
	list<char> fromConnect;
	for (int i = 1; i <= phase_num; i++)
	{	
		try
		{
        		std::getline(f, s);
		}
		catch(...)
		{
			return 1;
		}
	}
	cout<<s<<endl;
	for(int j=0;j<s.length();j++)
	{
		if(s[j]==':')
		{
			if(flag==1)
				break;
			else
			{
			 	fromConnect.clear();
			}
		}
		if(server_letter[server_num]==s[j])
		{
			flag=1;
			//fromConnect.push_back(s[j]);
			continue;
		}
		else if(flag!=1)
		{
			fromConnect.push_back(s[j]);
		}
		if(flag==1 && s[j]!=':')
		{
			size_t found0 = server_letter.find(s[j]);
			makeConnect[found0]=1;
		}
		
		
		///if(s[j]!=':')
		//{
		//	count++;
		//}
		
	}
	list<char>::iterator it;
	int l;
	for (l=0,it=fromConnect.begin(); it!=fromConnect.end(); ++it,l++)
	{
		size_t found0 = server_letter.find((*it));
    		makeConnect[found0]=0;
	}
	return end_file;
}
*/

//reading the phase of connection and disconnection
int readConfigure(int phase_num,int server_num,int makeConnect[8])
{
	char* serverIPList[8]={A,B,C,D,E,F,G,H};
	//int makeConnect[8]={-1,-1,-1,-1,-1,-1,-1,-1};
	std::ifstream f("Configure_Connection.txt");
	string s;
	string server_letter="ABCDEFGH";
	int flag=0;
	int end_file=0; 
	int count=0;
	list<int> fromConnect;
	for (int i = 1; i <= phase_num; i++)
	{	
		try
		{
        		std::getline(f, s);
		}
		catch(...)
		{
			return 1;
		}
	}
	cout<<s<<endl;
	for(int j=0;j<s.length();j++)
	{
		if(s[j]==':')
		{
			if(flag==1)
				break;
			else
			{
			 	fromConnect.clear();
			}
		}
		if(flag==1)
		{
			makeConnect[count]=1;
		}
		if(server_letter[server_num]==s[j])
		{
			flag=1;
		}
		else if(flag!=1)
		{
			fromConnect.push_back(j);
		}
		if(s[j]!=':')
		{
			count++;
		}
	}
	list<int>::iterator it;
	int l;
	for (l=0,it=fromConnect.begin(); it!=fromConnect.end(); ++it,l++)
	{
    		makeConnect[(*it)]=0;
	}
	return end_file;
}


//function to append the string to the file
void writeFile(char* filename,string appendText)
{

  	std::ofstream outfile;

  	outfile.open(filename, std::ios_base::app);
  	outfile << appendText<<endl;;


}
//function to get the last line from the file
string getLastLine(char* filename)
{
	std::string lastline;
	std::ifstream fs;
	fs.open(filename, std::fstream::in);
	if(fs.is_open())
	{
		//Got to the last character before EOF
		fs.seekg(-1, std::ios_base::end);
		if(fs.peek() == '\n')
		{
			//Start searching for \n occurrences
			fs.seekg(-1, std::ios_base::cur);
			int i = fs.tellg();
			for(i;i > 0; i--)
			{
				if(fs.peek() == '\n')
				{
 					 //Found
  					fs.get();
  					break;
				}		
				//Move one character back
				fs.seekg(i, std::ios_base::beg);
			}
		}

		getline(fs, lastline);
		std::cout << lastline << std::endl;
	}
	else
	{
		std::cout << "Could not find end line character" << std::endl;
		lastline="no content";
	}	
	return lastline;
}
//read thread struct
struct read_app
{
		list <SocketWrapper> *SocketConnectionList; // gives the number of components connected
		int socket_id;
		int connect_num;
		
};
void *readThreadFunction(void *threadarg)
{
	struct read_app *data;
	data = (struct read_app *) threadarg;
	char *close_msg="close";
	cout<<"Read Thread connected to SERVER"<<data->connect_num<<"with id:"<<data->socket_id<<endl;
	
	while(1)
	{
		char buf[1024]={0};
		int valread1;
		valread1 = read(data->socket_id  , buf, 1024); 
		cout<<string(buf)<<endl;
		string buffer(buf);
		
		size_t found0 = buffer.find("LOCK_REQUEST");
		size_t found1 = buffer.find("VOTE_REQUEST");
		size_t found2 = buffer.find("COMMIT");
		size_t found3 = buffer.find("ABORT");
		std::string delimiter = ":";
		if(valread1 && (strcmp(buf, "close") == 0))
		{
			break;
		}
		else if(valread1 && (found0 != string::npos))
		{
			
			if (!LOCK_REQUEST)
			{
				
				list <SocketWrapper> :: iterator it1;
				//for( it1 = SocketConnectionList->begin(); it1 != SocketConnectionList->end(); ++it1) 
				//{
				//	if((*it1).connect_num==data->connect_num)
				//	{
						//cout<<"sending msg with id:"<<data->socket_id<<" to server"<<data->connect_num<<endl;
						char fileStatus[100]={0};
						snprintf( fileStatus, sizeof(fileStatus), "VOTE_REQUEST:%d :%d :%c",VN,RU,DS);
						send(data->socket_id, fileStatus , strlen(fileStatus) , 0 );
				//		break;
				//	}
				//}
				
				LOCK_REQUEST=TRUE;
			}
		}
		else if(valread1 && (found1 != string::npos))
		{
			if(LOCK_REQUEST)
			{
				int RU_final;
				char DS_final;
				waiting_reply--; //received a  reply
				cout<<"buffer msg::"<<buffer<<endl;
				size_t pos = 0;
				std::string token;
				pos = buffer.find(":");
				token = buffer.substr(0, buffer.find(":"));
				cout<<"message::"<<token<<endl;
				buffer.erase(0, pos + delimiter.length());

				pos = buffer.find(":");
				token = buffer.substr(0, buffer.find(":"));
				cout<<"VN::"<<token<<endl;
				int temp_VN=stoi(token); //string might fail
				if(M<temp_VN)
					M=temp_VN;
				buffer.erase(0, pos + delimiter.length());
				//cout<<"current cardinality::"<<(data->SocketConnectionList)->size()<<endl;
				
				pos = buffer.find(":");
				token = buffer.substr(0, buffer.find(":"));
				cout<<"RU::"<<token<<endl;
				
				int temp_RU=stoi(token);
				buffer.erase(0, pos + delimiter.length());
				while(waiting_reply!=0)  // wait for all the reply of VN
				{
				}
				
				pos = buffer.find(":");
				token = buffer.substr(0, buffer.find(":"));
				cout<<"DS::"<<token<<endl;
				char temp_DS=token[token.size()-1];
				cout<<"Status of SERVER:"<<data->connect_num<<" VN:"<<temp_VN<<" RU:"<<temp_RU<<" DS:"<<temp_DS<<endl;
				if(Update_Flag)
				{
					Update_Flag=FALSE;
					if(temp_VN==M)
					{
						RU_final=temp_RU;
						//DS_final=temp_DS;	
					}
					//bool temp_success=FALSE;
					if(RU_final/2<(data->SocketConnectionList)->size())
					{
						Update_Success=TRUE;
						//temp_success=TRUE;	
					
					}
					else if(RU_final/2==(data->SocketConnectionList)->size())
					{
						int check_DS=DS-'A';
						list <SocketWrapper> :: iterator it1;
						for( it1 = (data->SocketConnectionList)->begin(); it1 != (data->SocketConnectionList)->end(); ++it1) 
						{
							if((*it1).connect_num==check_DS)
							{
							Update_Success=TRUE;
							break;
							}
						}					
					
					}
					else
					{
						Update_Success=FALSE;
					}
				
					if(Update_Success)
					{
					
										
						VN=M;
						VN++;
						RU=(data->SocketConnectionList)->size();
						int DS_low=8;
						list <SocketWrapper> :: iterator it1;
						for( it1 = (data->SocketConnectionList)->begin(); it1 != (data->SocketConnectionList)->end(); ++it1) 
						{
							if((*it1).connect_num<DS_low)
							{
								DS_low=(*it1).connect_num;
							}
						}
						if(findServerNum(getIPAddress())<DS_low)
						{
							DS_low=findServerNum(getIPAddress());
						}
						DS='A'+ DS_low;
						for( it1 = (data->SocketConnectionList)->begin(); it1 != (data->SocketConnectionList)->end(); ++it1) 
						{
							if((*it1).connect_num!=10 || (*it1).connect_num!=findServerNum(getIPAddress()))
							{
								char fileStatus[100]={0};
								snprintf( fileStatus, sizeof(fileStatus), "COMMIT:%d :%d :%c",VN,RU,DS);
								if((*it1).receiver==getIPAddress())
								{
									 send((*it1).socket_id.return_accept_socket(), fileStatus , strlen(fileStatus) , 0 );
							
								}
								else
								{
									send((*it1).socket_id.socket_fd, fileStatus , strlen(fileStatus) , 0 );
								
								}
				
							}
						}
					
						cout<<"VN updated"<<endl;
					
					}
					else
					{
					
					
						list <SocketWrapper> :: iterator it1;
						for( it1 = (data->SocketConnectionList)->begin(); it1 != (data->SocketConnectionList)->end(); ++it1) 
						{
							if((*it1).connect_num!=10 || (*it1).connect_num!=findServerNum(getIPAddress()))
							{
								char fileStatus[100]={0};
								snprintf( fileStatus, sizeof(fileStatus), "ABORT");
								if((*it1).receiver==getIPAddress())
								{
									 send((*it1).socket_id.return_accept_socket(), fileStatus , strlen(fileStatus) , 0 );
							
								}
								else
								{
									send((*it1).socket_id.socket_fd, fileStatus , strlen(fileStatus) , 0 );
								
								}
				
							}
						}
				 	cout<<"write aborted"<<endl;
					
					}
				//Update for sucess
				
				LOCK_REQUEST=FALSE;
				}
			}
		}
		else if(valread1 && (found2 != string::npos))
		{
			if(LOCK_REQUEST)
			{
				size_t pos = 0;
				std::string token;
				pos = buffer.find(":");
				token = buffer.substr(0, buffer.find(":"));
				cout<<"message::"<<token<<endl;
				buffer.erase(0, pos + delimiter.length());
		
				pos = buffer.find(":");
				token = buffer.substr(0, buffer.find(":"));
				cout<<"VN::"<<token<<endl;
				VN=stoi(token); //string might fail
				buffer.erase(0, pos + delimiter.length());

				pos = buffer.find(":");
				token = buffer.substr(0, buffer.find(":"));
				cout<<"RU::"<<token<<endl;
				RU=stoi(token);
				buffer.erase(0, pos + delimiter.length());

				pos = buffer.find(":");
				token = buffer.substr(0, buffer.find(":"));
				cout<<"DS::"<<token<<endl;
				DS=token[token.size()-1];
				cout<<"Write Success!"<<endl;
				LOCK_REQUEST=FALSE;
				Update_Flag=TRUE;
			}
		}
		else if(valread1 && (found3 != string::npos))
		{
			if(LOCK_REQUEST)
			{
				cout<<"Write Failed!"<<endl;
				LOCK_REQUEST=FALSE;
				Update_Flag=TRUE;
			}
		}
		
	}
}

//listen thread Struct
struct listenThreadStruct
{
	list <SocketWrapper> *SocketConnectionList;
};
//decalring globally
pthread_t readThreadApplication[8];
struct read_app R[8];
// this thread always listen in the port 2408 and updates the list
void *listenThread(void *threadarg)
{
	struct listenThreadStruct *data;
	data = (struct listenThreadStruct *) threadarg;
	cout<<"Listen Thread Started"<<endl;
	char *setup_msg = "received";
	
	while(terminate_socket)
	{
		Socket_connection s1;
		s1.listen_socket();
		while(1)
		{	
			int stat=s1.return_accept_response();
			if (stat==1) 
			{	
			
				send(s1.return_accept_socket(), setup_msg , strlen(setup_msg) , 0 ); 
				SocketWrapper w1;
				w1.sender=inet_ntoa(s1.address.sin_addr);
				w1.receiver=getIPAddress();
				w1.socket_id=s1;
				if(string(inet_ntoa(s1.address.sin_addr))==con)
				{
					w1.connect_num=10;
				}
				else
				{
					w1.connect_num=findServerNum(string(inet_ntoa(s1.address.sin_addr)));
				}
				//pthread_mutex_lock(&list_lock);
				(data->SocketConnectionList)->push_back(w1);
				//pthread_mutex_unlock(&list_lock);
				cout<<"Receiver - connected from SERVER "<<findServerNum(inet_ntoa(s1.address.sin_addr)) <<" to SERVER "<<findServerNum(getIPAddress())<<endl;
				//read thread created after adding in list
				if(w1.connect_num!=10)
				{
					
					
					R[w1.connect_num].connect_num=findServerNum(string(inet_ntoa(s1.address.sin_addr)));//(*iterator1).connect_num;
					R[w1.connect_num].socket_id=s1.return_accept_socket();
					R[w1.connect_num].SocketConnectionList=data->SocketConnectionList;
					int rc = pthread_create(&readThreadApplication[w1.connect_num], NULL, readThreadFunction, (void *)&R[w1.connect_num]);
					if (rc)
					{
						cout<<"Problem with the creating exit thread.."<<endl;
						return 0;	
					}
				}					
			}
			else
			{	
				cout<<"couldnt connect to the socket-receiver side"<<endl;
		
			}
		
		
		}
		close_flag=TRUE;
	}


}



// Make connection.. Server waits to connect to all threads
int makeConnection(list <SocketWrapper> *SocketConnectionList)
{	
	cout<<"Main Client Thread created"<<endl;
	int phase=4;//number of stage... this has to be entered manually... it is the length of the configure file
	char* serverIPList[8]={A,B,C,D,E,F,G,H};
	int connection_start=0,status,client_num,flag=0;
	char *setup_msg = "received";
	//char *end_msg = "end_connect";
	//char *setup_msg = "start";
	char *close_msg ="close";
	
	int valread=0;
	//int received_pre_msg=0;
	int server_num;
	server_num=findServerNum(getIPAddress());
	cout<<"I am a Server no:"<<server_num <<" and My Ip address is::"<<getIPAddress()<<endl;
	
	//creating the generic listen thread that listens in the PORT 2408 and push the socket to the List.
	pthread_t listen_application;
	struct listenThreadStruct l;
	l.SocketConnectionList=SocketConnectionList;
	int rc = pthread_create(&listen_application, NULL, listenThread, (void *)&l);
	if (rc)
	{
		cout<<"Problem with the creating listen thread.."<<endl;
		return 0;	
	}


	int phase_num=0;
	//while skipping cin
	
	//cout<<"Enter 1 to chage the Phase of the Connection:";
	while(1)//for(int k=0;k<phase;k++)
	{

		string Phase_Shift;
			
		char Controller_msg[1024]={0};
		list <SocketWrapper> :: iterator it1;
		
		for( it1 = SocketConnectionList->begin(); it1 != SocketConnectionList->end(); ++it1) 
		{
			if((*it1).connect_num==10)
			{
				valread = read((*it1).socket_id.return_accept_socket(), Controller_msg, 1024); 
				break;
			}
		}
		string Controller_buffer(Controller_msg);
		size_t found0 = Controller_buffer.find("write");
		std::string delimiter = ":";
		if(strcmp(Controller_msg,"phase")==0 && valread)
		{
			if(phase_num>5)// 5 is the number of lines in the configure text
			{	
				cout<<"Exiting beacuse configure file ended"<<endl;
				break;
			}
			int makeConnect[8]={-1,-1,-1,-1,-1,-1,-1,-1};
			phase_num=phase_num+1;
			int end_file=readConfigure(phase_num,server_num,makeConnect);
			if(end_file)
			{
				cout<<"File Ended"<<endl;
				break;
			}
			cout<<"Iteration "<<phase_num<<endl;
			for(int i=0;i<8;i++)
			{
				cout<<makeConnect[i];
			}
			cout<<endl;
			for(int i=0;i<8;i++)
			{
				if(makeConnect[i]==-1)
				{
					list <SocketWrapper> :: iterator it;	
					for(it = SocketConnectionList->begin(); it != SocketConnectionList->end(); ++it) 
					{
						if((*it).connect_num==i)
						{
							if((*it).receiver==getIPAddress())
							{
								send((*it).socket_id.return_accept_socket(), close_msg , strlen(close_msg) , 0 ); 
								//close all the socket connection and pushing the node out of the list
								////shutdown((*it).socket_id.socket_fd,3);
								shutdown((*it).socket_id.return_accept_socket(),3);
								////close((*it).socket_id.socket_fd);
								//close_flag=FALSE;
								close((*it).socket_id.return_accept_socket());
							
							}
							else
							{
								send((*it).socket_id.socket_fd, close_msg , strlen(close_msg) , 0);
								shutdown((*it).socket_id.socket_fd,3);
								close((*it).socket_id.socket_fd);
							}		
							cout<<"Removing the node SERVER "<< findServerNum((*it).sender)<<" connected to SERVER "<<findServerNum((*it).receiver)<<endl;
							it=SocketConnectionList->erase(it);
							break;
						}
			
					}
				}
			}
			cout<<endl;
			int skip;
			

			for(int i=0;i<8;i++)
			{
				skip=0;
				if(makeConnect[i]==1)
				{
					list <SocketWrapper> :: iterator itt;
					int l;
					for(l=0, itt = SocketConnectionList->begin(); itt != SocketConnectionList->end(); ++itt,l++) 
					{
						if((*itt).sender==string(serverIPList[i]) || (*itt).receiver==string(serverIPList[i]))
						{
							skip=1;
							break;
						}
					}
					if (skip==1)
					{
						continue;
					}
					
					Socket_connection s1; //created for the sender clients
					SocketWrapper w1;
					w1.sender=getIPAddress();
					w1.receiver=serverIPList[i];
					w1.connect_num=findServerNum(string(serverIPList[i]));
					//connecting other servers
					int stat=s1.connect_socket(serverIPList[i]);
					w1.socket_id=s1;
					if (stat==1)
					{	
						
						char buf[1024]={0};
						int valread1;
						valread1 = read(s1.socket_fd  , buf, 1024); 
						//cout<<string(buf)<<endl;
						if(valread1 && (strcmp(buf, "received") == 0))
						{
							//pthread_mutex_lock(&list_lock);
							SocketConnectionList->push_back(w1); //need mutex here
							//pthread_mutex_unlock(&list_lock);
							cout<<"Sender - connected "<< w1.sender <<" to "<< w1.receiver <<endl;
						}
					}
					else
					{
						cout<<"error in sending the client connect.."<<endl;
		
					}
					//pthread_t readThreadApplication;
					//struct read_app R;
					R[w1.connect_num].connect_num=i;//(*iterator1).connect_num;
					R[w1.connect_num].socket_id=s1.socket_fd;
					R[w1.connect_num].SocketConnectionList=SocketConnectionList;
					int rc = pthread_create(&readThreadApplication[w1.connect_num], NULL, readThreadFunction, (void *)&R[w1.connect_num]);
					if (rc)
					{
						cout<<"Problem with the creating exit thread.."<<endl;
						return 0;	
					}		
					/*
					pthread_t readThreadApplication;
					struct read_app R;
					list <SocketWrapper> :: iterator iterator1;
					int s;
					for(s=0, iterator1 = SocketConnectionList->begin(); iterator1 != SocketConnectionList->end(); ++iterator1,s++) 
					{
						if((*iterator1).connect_num==i)
						{
							cout<<"seeding read thread for SERVER"<<(*iterator1).connect_num<<endl;
							R.connect_num=i;//(*iterator1).connect_num;
							if((*iterator1).sender==getIPAddress())
							{
							R.socket_id=(*iterator1).socket_id.socket_fd;
							}
							else
							{
							R.socket_id=(*iterator1).socket_id.return_accept_socket();
							}
						}
					}
					
					R.SocketConnectionList=SocketConnectionList;
					int rc = pthread_create(&readThreadApplication, NULL, readThreadFunction, (void *)&R);
					if (rc)
					{
						cout<<"Problem with the creating exit thread.."<<endl;
						return 0;	
					}
					*/
				}
				
			}
			
					
		}
		else if((found0 != string::npos) && valread)
		{
			cout<<"Initiate the Write Sequence"<<endl;
			if(SocketConnectionList->size()==1)
			{
				cout<<"Write Aborted"<<endl;
			}
			else
			{
				LOCK_REQUEST=TRUE;
				Update_Success=FALSE;
				Update_Flag=TRUE;
				//size_t pos = 0;
				//std::string token;
				//pos = Controller_buffer.find(":");
				//token = Controller_buffer.substr(0, Controller_buffer.find(":"));
				//Controller_buffer.erase(0, pos + delimiter.length());
				//pos = Controller_buffer.find(":");
				//token = Controller_buffer.substr(0, Controller_buffer.find(":"));
				//cout<<"Update the following message to my Quorem::"<<token<<endl;
				waiting_reply=SocketConnectionList->size()-1;
				//RU=SocketConnectionList->size();

				list <SocketWrapper> :: iterator iterator1;
				int s;
				for(s=0, iterator1 = SocketConnectionList->begin(); iterator1 != SocketConnectionList->end(); ++iterator1,s++) 
				{
					if((*iterator1).connect_num!=10)
					{
						char fileStatus[100]={0};
						snprintf( fileStatus, sizeof(fileStatus), "LOCK_REQUEST");
						if((*iterator1).sender==getIPAddress())
						{
							send((*iterator1).socket_id.socket_fd, fileStatus , strlen(fileStatus) , 0 );
							cout<<"LOCK_REQUEST sent to SERVER"<<findServerNum((*iterator1).receiver)<<endl;
						}
						else
						{
							send((*iterator1).socket_id.return_accept_socket(), fileStatus , strlen(fileStatus) , 0 );
							cout<<"LOCK_REQUEST sent to SERVER"<<findServerNum((*iterator1).sender)<<endl;
						}
					}
				}
			}
			
		}
		else if(strcmp(Controller_msg,"end")==0  && valread)
		{
			cout<<"End the Transactions"<<endl;
			cout<<"SYSTEM EXIT"<<endl;
			//sleep(1);
			exit(0);
			break;
		}
		//cout<<"--------------------------"<<endl;
		/*
		list <SocketWrapper> :: iterator it;
		for(it = SocketConnectionList->begin(); it != SocketConnectionList->end(); ++it) 
		{
			cout<<"SERVER "<<findServerNum((*it).sender)<<" connected to SERVER "<<findServerNum((*it).receiver)<<endl;
			
		}
		*/
		
	}	

/*
	if (server_num==1)
	{	
		cout<<"Enter 1 to setup server connection: ";
		cin>>connection_start;
		if (!(connection_start==1))
		{	
			cout<<"invalid parameter.. enter 1 to setup connection ..exiting...";
			return 0;
		}
		
	}
	else
	{
		Socket_connection s1;
		s1.listen_socket();
		int stat=s1.return_accept_response();
		send(s1.return_accept_socket(), setup_msg , strlen(setup_msg) , 0 ); 
		SocketWrapper w1;
		w1.sender=inet_ntoa(s1.address.sin_addr);
		w1.receiver=getIPAddress();
		w1.socket_id=s1;
		w1.connect_num=findServerNum(string(inet_ntoa(s1.address.sin_addr)));
		//pthread_mutex_lock(&list_lock);
		SocketConnectionListServer->push_back(w1);
		//pthread_mutex_unlock(&list_lock);
		cout<<"Receiver - connected from "<<inet_ntoa(s1.address.sin_addr) <<" to "<<getIPAddress()<<endl;
	}

	for(int i=0;i<5;i++)
	{
		
		Socket_connection s1; //created for the sender clients
		SocketWrapper w1;
		w1.sender=getIPAddress();
		w1.receiver=clientIPList[i];
		w1.connect_num=findClientNum(string(clientIPList[i]));
		//connecting the clients in mesh
		int stat=s1.connect_socket(clientIPList[i]);
		w1.socket_id=s1;
		if (stat==1)
		{	
			
			char buf[1024]={0};
			valread = read(s1.socket_fd  , buf, 1024); 
			if(valread && (strcmp(buf, "received") == 0))
			{
				pthread_mutex_lock(&list_lock);
				SocketConnectionList->push_back(w1); //need mutex here
				pthread_mutex_unlock(&list_lock);
				cout<<"Sender - connected "<< w1.sender <<" to "<< w1.receiver <<endl;
			}
		}
		else
		{
			cout<<"error in sending the client connect.."<<endl;
		
		}
		
	}
	for(int i=1;i<8;i++)
	{
		if (!(2 * server_num==i || (2 * server_num)+1==i))
			continue;
		Socket_connection s1; //created for the sender clients
		SocketWrapper w1;
		w1.sender=getIPAddress();
		w1.receiver=serverIPList[i-1];
		w1.connect_num=i-1;
		//connecting the clients in mesh
		int stat=s1.connect_socket(serverIPList[i-1]);
		w1.socket_id=s1;
		if (stat==1)
		{	
			
			char buf[1024]={0};
			valread = read(s1.socket_fd  , buf, 1024); 
			
			if(valread && (strcmp(buf, "received") == 0))
			{
				
				pthread_mutex_lock(&list_lock);
				SocketConnectionListServer->push_back(w1); //need mutex here
				pthread_mutex_unlock(&list_lock);
				cout<<"Sender - connected "<< w1.sender <<" to "<< w1.receiver <<endl;
			}
		}
		else
		{
			cout<<"error in sending the client connect.."<<endl;
		
		}
		

	}
*/
	cout<<"Connection completed"<<endl;	
}

/*
struct Reply_thread_data
{
	int socket;
	int client_num;
	int socket_list[5];
};
//Respond to the Client request of ENQUIRE,WRITE and READ
void *REPLY_CS(void *threadarg)
{
	struct Reply_thread_data *data;
	data = (struct Reply_thread_data *) threadarg;
	char finish_msg[100] ={0};
	char filesList[100]={0};
	
	while(1)
	{
		
		char buf[100]={0};
		
		int valread = read(data->socket, buf, 100); 
		
		string buffer(buf);
		
		size_t found0 = buffer.find("REQUEST");
		size_t found1 = buffer.find("RELEASE");
		size_t found2 = buffer.find("END");
		size_t found3 = buffer.find("start");
		//cout<<"Received message "<<buffer<<endl;
		pthread_mutex_lock(&message_received_count_lock);
		message_received_count++;
		pthread_mutex_unlock(&message_received_count_lock);
		std::string delimiter = ":";
		char time_content[100]={0};		
		if(valread && (found0 != string::npos))
		{	
			if(!LOCKED)
			{
				pthread_mutex_lock(&LOCKED_lock);
				LOCKED=TRUE;
				pthread_mutex_unlock(&LOCKED_lock);
				snprintf( filesList, sizeof(filesList), "%s", "GRANT");
				send(data->socket, filesList , strlen(filesList) , 0 );
				cout<<"Sending GRANT measage to CLIENT:"<<data->client_num<<endl;
				pthread_mutex_lock(&message_sent_count_lock);
				message_sent_count++;
				pthread_mutex_unlock(&message_sent_count_lock);
			}
			else
			{
				
				size_t pos = 0;
				std::string token;
				pos = buffer.find(":");
				token = buffer.substr(0, buffer.find(":"));
				buffer.erase(0, pos + delimiter.length());
				pos = buffer.find(":");
				token = buffer.substr(0, buffer.find(":"));
				
				snprintf( time_content, sizeof(time_content), "%s-%d", token.c_str(),data->client_num);
				QUEUE.push(time_content);
				cout<<"push request from CLIENT:"<<data->client_num<<" to QUEUE::content "<<time_content<<endl;
			}
			

		}
		else if(valread && (found1 != string::npos))
		{
			if(QUEUE.empty())
			{
				pthread_mutex_lock(&LOCKED_lock);
				LOCKED=FALSE;
				pthread_mutex_unlock(&LOCKED_lock);
				cout<<"queue is empty and not locked"<<endl;
			}
			else
			{
				
				string time_order;
				cout<<QUEUE.top()<<endl;;
				time_order=QUEUE.top();
				cout<<"POP out of the QUEUE:"<<time_order<<endl;
				QUEUE.pop();
				size_t pos = 0;
				std::string token;
				pos = time_order.find("-");
				token = time_order.substr(0, time_order.find("-"));
				time_order.erase(0, pos + delimiter.length());
				
				pos = time_order.find("-");
				token = time_order.substr(0, time_order.find("-"));
				
				snprintf( filesList, sizeof(filesList), "%s", "GRANT1");
				send(data->socket_list[stoi(token)-1], filesList , strlen(filesList) , 0 );
				cout<<"Sending GRANT message to CLIENT::"<<token<<endl;
				pthread_mutex_lock(&message_sent_count_lock);
				message_sent_count++;
				pthread_mutex_unlock(&message_sent_count_lock);
				
			}

		}
		else if(valread && (found2 != string::npos))
		{
			
			cout<<"Termination message reached from CLIENT"<<data->client_num<<endl;
			pthread_mutex_lock(&exit_number_lock);
			exit_number--;			
			pthread_mutex_unlock(&exit_number_lock);
			break;
		}else if(valread && (found3 != string::npos))
		{
			while( !QUEUE.empty() ) 
			{			
				QUEUE.pop();
			}
			LOCKED=FALSE;
			message_sent_count=0;
			message_received_count=0;
		}
		
	}

}

//Reply thread to handle all the transaction
int ReplyClient(list <SocketWrapper> *SocketConnectionList)
{
	
	pthread_t REPLY[5];
	struct Reply_thread_data Rep[5];
	int l;
	//int socket_list[6];
	list <SocketWrapper> :: iterator itt;
	for(int i=0;i<5;i++)
	{
		for(l=0, itt = SocketConnectionList->begin(); itt != SocketConnectionList->end(); ++itt,l++) 
		{
			Rep[i].socket_list[(*itt).connect_num-1]=((*itt).socket_id).socket_fd;
		}
	}
	for(l=0, itt = SocketConnectionList->begin(); itt != SocketConnectionList->end(); ++itt,l++) 
	{
		
		Rep[l].socket=((*itt).socket_id).socket_fd;
		Rep[l].client_num=(*itt).connect_num;
		
		int rc = pthread_create(&REPLY[l], NULL, REPLY_CS, (void *)&Rep[l]);
		if (rc)
		{
			cout<<"Problem with the creating Reply Thread.."<<endl;
			return 0;	
		}
	}
	

}
struct exit_app
{
	list <SocketWrapper> *SocketConnectionList;
	
};
//thread to close all the sockets and exit application 
void *exit_fn(void *threadarg)
{
	struct exit_app *data;
	data = (struct exit_app *) threadarg;
	int l;
	list <SocketWrapper> :: iterator itt;
	int flag=0;
	while(1)
	{
		if(exit_number==0 && flag==0)
		{	
			if (getIPAddress()==A)
			{
				for(l=0, itt = (data->SocketConnectionList)->begin(); itt != (data->SocketConnectionList)->end(); ++itt,l++) 
				{ 
					char exit[100]={0};
					snprintf( exit, sizeof(exit), "%s", "END");
					send(((*itt).socket_id).socket_fd,&exit , strlen(exit) , 0);	
					cout<<"Sent END message to "<<(*itt).receiver<<endl;

				}
			}
			flag=1;
			exit_number--;
			sleep(3);
		}
		if(exit_number==-1)
		{
			cout<<"MESSAGE TRANSACTION STATS:"<<endl;
			cout<<"**************************"<<endl;
			cout<<"Total Number of Message Sent    ::"<<message_sent_count<<endl;
			cout<<"Total Number of Message Received::"<<message_received_count<<endl<<endl;
			
			for(itt = (data->SocketConnectionList)->begin(); itt != (data->SocketConnectionList)->end(); ++itt) 
			{
				close(((*itt).socket_id).socket_fd);
				close(((*itt).socket_id).new_socket);
			}
		
			cout<<"SYSTEM EXIT"<<endl;
			exit(0);// force all thread to exit
		}
	}	
}

struct restart_app
{
	list <SocketWrapper> *SocketConnectionList;
	
};
//thread to close all the sockets and exit application 
void *restart_fn(void *threadarg)
{
	struct exit_app *data;
	data = (struct exit_app *) threadarg;
	int l;
	list <SocketWrapper> :: iterator itt;
	char finish_msg[100]={0};
	string restart_msg;
	if (getIPAddress()==A)
	{
		while(1)
		{
			cout<<"Type \"start\" to start the transaction"<<endl;
			cin>>restart_msg;
			
			if(restart_msg=="start")
			{
			
				cout<<"******START QUORUM TRANSCATION********"<<endl;
				for(itt = (data->SocketConnectionList)->begin(); itt != (data->SocketConnectionList)->end(); ++itt) 
				{
					snprintf( finish_msg, sizeof(finish_msg), "%s", "start");
					send(((*itt).socket_id).socket_fd, &finish_msg , strlen(finish_msg) , 0 );
				}
		
		
			}
			else
			{
				cout<<"Not a Valid start message"<<endl;
			}
		}
	}
}

*/



//Main Function
int main()
{	
	list <SocketWrapper> SocketConnectionList;
	//list <SocketWrapper> SocketConnectionListServer;
	int status=makeConnection(&SocketConnectionList);
	if(status==0)
	{
		cout<<"Problem with connection/disconnection setup.."<<endl;
		return 1;	
	}
	/*
	pthread_t restart_application;
	struct restart_app r;
	r.SocketConnectionList=&SocketConnectionList;
	int res = pthread_create(&restart_application, NULL, restart_fn, (void *)&r);
	if (res)
	{
		cout<<"Problem with the creating Restart Thread.."<<endl;
		return 0;	
	}
	pthread_t exit_application;
	struct exit_app e;
	e.SocketConnectionList=&SocketConnectionList;
	int rc = pthread_create(&exit_application, NULL, exit_fn, (void *)&e);
	if (rc)
	{
		cout<<"Problem with the creating exit thread.."<<endl;
		return 0;	
	}
	int stat=ReplyClient(&SocketConnectionList);
	if(stat==0)
	{
		cout<<"Problem with Reply thread Connection"<<endl;
		return 1;	
	}
	*/
	cout<<"Back to Main Connection"<<endl;
	while(1)
	{
	}
		
	return 0;
}


///////c
////////////////////////////////////////////////
//
//
//      CS 6378 - PROJECT 2
//      MUTUAL EXCLUSION - QUORUM
//            Controller
//
//
/////////////////////////////////////////////////
#include "connection.h"

using namespace std;

#define TRUE             1
#define FALSE            0
typedef int64_t msec_t;
//Global mutex for receiving threads
pthread_mutex_t list_lock;
pthread_mutex_t server_list_lock;
pthread_mutex_t struct_lock;
pthread_mutex_t Id_thread_lock;
pthread_mutex_t expected_grant_lock;
pthread_mutex_t message_received_count_lock;
pthread_mutex_t message_sent_count_lock;
//Global variable for thread control
int Id_thread=0;
int connect_complete=0; 
int expected_grant=4;
int start_transaction=0;
int unit_delay=100000;//100 miliseconds
int message_sent_count=0;
int message_received_count=0;
int deadlock_count=-1;
bool exit_number=0;
pthread_t start_Quorum[30];
//Grab the IP Address of the current machine
string getIPAddress()
{
    	string ipAddress="Unable to get IP Address";
    	struct ifaddrs *interfaces = NULL;
    	struct ifaddrs *temp_addr = NULL;
    	int success = 0;
    
    	success = getifaddrs(&interfaces);
    	if (success == 0) 
	{
        
        	temp_addr = interfaces;
        	while(temp_addr != NULL) 
		{
            		if(temp_addr->ifa_addr->sa_family == AF_INET) 
			{
                
                		if(strcmp(temp_addr->ifa_name, "en0"))
				{
                    			ipAddress=inet_ntoa(((struct sockaddr_in*)temp_addr->ifa_addr)->sin_addr);
                		}
            		}
            	temp_addr = temp_addr->ifa_next;
        	}
    	}
   
    	freeifaddrs(interfaces);
    	return ipAddress;
}

msec_t time_ms(void)
{
    struct timeval tv;
    gettimeofday(&tv, NULL);
    return (msec_t)tv.tv_sec * 1000 + tv.tv_usec / 1000;
}
///Creating a class to deal with lower socket 
class Socket_connection
{
public:
	int socket_fd, new_socket, valread; 
	struct sockaddr_in address; 
	int opt = 1; 
	int addrlen = sizeof(address); 
	int iMode=0;
	Socket_connection()
	{
		// Creating socket file descriptor 
		if ((socket_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) 
		{ 
			perror("socket failed"); 
			exit(EXIT_FAILURE); 
		} 
		bzero((char *) &address, sizeof(address));
		ioctl(socket_fd, FIONBIO, &iMode); 
		address.sin_port = htons( PORT );
		address.sin_family = AF_INET;
		 
	}
	Socket_connection(const Socket_connection &sock)  //copy constructor
	{
	socket_fd=sock.socket_fd;
	new_socket=sock.new_socket; 
	valread=sock.valread;
	address=sock.address; 
	opt=1;
	addrlen =sock.addrlen;
	iMode=0;

	}
	~Socket_connection()  //destructor
	{
	
	}
	int connect_socket(char* IPname)
	{	
		
		
		if(inet_pton(AF_INET, IPname, &address.sin_addr)<=0)  
    		{ 
        		cout<<"Invalid address/ Address not supported "<<endl; 
        		return 0; 
    		}		
		
		if(connect(socket_fd, (struct sockaddr *)&address, sizeof(address))<0) 
		{
			cout<<"Connection Failed "<<endl; 
        		return 0;
		}
		else
		{
			return 1;
		}
		
		
		
    		
	}
	int listen_socket()
	{	
		
		// Forcefully attaching socket to the port 2408 
		if (setsockopt(socket_fd, SOL_SOCKET, (SO_REUSEPORT | SO_REUSEADDR),&opt, sizeof(opt))) 
		{ 
		perror("setsockopt"); 
		exit(EXIT_FAILURE); 
		} 
		address.sin_addr.s_addr = INADDR_ANY; 
		
		// Forcefully attaching socket to the port 8080 
		if (bind(socket_fd, (struct sockaddr *)&address, sizeof(address))<0) 
		{ 
		perror("bind failed"); 
		return 0; 
		} 
		
		if (listen(socket_fd, 32) < 0) 
		{ 
		perror("listen failed"); 
		return 0; 
		} 
		
	}
	int return_accept_response()
	{
		
		if ((new_socket = accept(socket_fd, (struct sockaddr *)&address,(socklen_t*)&addrlen))<0) 
		{ 
		perror("accept failed"); 
		return 0; 
		} 
		else
		{
			return 1;
		}
		
	}
	int return_accept_socket()
	{
		return new_socket;
	}
	
			
};

//Creating a wrapper for the socket with sender and receiver information
class SocketWrapper
{
public:
	string sender;
	string receiver;
	Socket_connection socket_id;
	int connect_num;
	SocketWrapper()
	{
		sender="";
		receiver="";

	}
	SocketWrapper(const SocketWrapper &wrap)//copy constructor
	{
		sender=wrap.sender;
		receiver=wrap.receiver;
		socket_id=wrap.socket_id;
		connect_num=wrap.connect_num;

	}
	~SocketWrapper()//destructor
	{
	}
	
};
/*
////Struct to pass multiple parameter for all threads
struct Request_thread_data
{
	int client_num;
	int *Seq_num;
	int socket;
	int resource_num;

};
struct Reply_thread_data_array
{
	struct Reply_thread_data *Reply;
};
struct Reply_thread_data
{
	int client_num;
	int Seq_num=0;
	int Highest_Seq_num;
	bool Reply_Deferred[5];
	bool Using;
	bool Waiting;
	bool A[5];
	int socket[5];

};
struct Client_send_data
{
	int client_num;
	list <SocketWrapper> *SocketConnectionList;
	list <SocketWrapper> *SocketConnectionListServer;
	int over_ride;

};
*/
//find the server number
int findServerNum(string IP)
{
	char* serverIPList[8]={A,B,C,D,E,F,G,H};	
	int N=8; //Total number of Clients
	int server_num=0;
	for(int i=0;i<N;i++)// find the client number
	{
		if(IP==string(serverIPList[i]))
		{
			server_num=i;
			break;	
		}
	}
	return server_num;
}
/*
//Function returns the current client number with the ip passed as parameter
int findClientNum(string IP)
{
	char* clientIPList[5]={CLIENT1,CLIENT2,CLIENT3,CLIENT4,CLIENT5};
	
	int N=5; //Total number of Clients
	int client_num=0;
	for(int i=0;i<N;i++)// find the client number
	{
		if(IP==string(clientIPList[i]))
		{
			client_num=i;
			break;	
		}
	}
	return client_num+1; //the clients are addressed from 1-5
}

//function to append the string to the file
void writeFile(msec_t now)
{
	char* clientIPList[5]={CLIENT1,CLIENT2,CLIENT3,CLIENT4,CLIENT5};
	// current date/time based on current system
	msec_t t2=time_ms();
  	std::ofstream outfile;
	msec_t dif=(t2-now);
	
	
	char time_val[100]={0};
	snprintf( time_val, sizeof(time_val), "%lu", now);
	char diff_val[100]={0};
	snprintf( diff_val, sizeof(diff_val), "%lu", dif);
	
  	outfile.open("/home/012/j/jx/jxb162030/Desktop/aos_Project_2/file1.txt", std::ios_base::app);
  	outfile <<"Time: " <<time_val<<" wrote by CLIENT"<<findClientNum(getIPAddress())<<" ::"<<clientIPList[findClientNum(getIPAddress())-1]<<" and The Time elapsed for this Quorum transaction::"<<diff_val<<endl;


}
*/
//Main function to trigger connection to other clients and Servers in thread
int makeConnection(list <SocketWrapper> *SocketConnectionListServer)
{	
	cout<<"Main Client Thread created"<<endl;
	int value;
	char* serverIPList[8]={A,B,C,D,E,F,G,H};
	int valread;
	int connection_start=0,status,client_num,flag=0,rc;
	char *setup_msg = "received";
	cout<<"I am an server controller and My Ip address is::"<<getIPAddress()<<endl;
	cout<<"Type 1 to start connection:"<<endl;	
	cin>>value;
	while(1)
	{
		if(value==1)
		{
			for(int i=0;i<8;i++)
			{
				Socket_connection s1; //created for the sender clients
				SocketWrapper w1;
				w1.sender=getIPAddress();
				w1.receiver=serverIPList[i];
				w1.connect_num=findServerNum(string(serverIPList[i]));
				//connecting other servers
				int stat=s1.connect_socket(serverIPList[i]);
				w1.socket_id=s1;
				if (stat==1)
				{	

					char buf[1024]={0};
					valread = read(s1.socket_fd  , buf, 1024); 
					if(valread && (strcmp(buf, "received") == 0))
					{
						pthread_mutex_lock(&list_lock);
						SocketConnectionListServer->push_back(w1); //need mutex here
						pthread_mutex_unlock(&list_lock);
						cout<<"Sender - connected "<< w1.sender <<" to "<< w1.receiver <<endl;
					}
				}
				else
				{
					cout<<"error in sending the client connect.."<<endl;

				}
			}
			break;
		}
		else
		{
			cout<<"Please Enter 1 to start connection"<<endl;
		}
	}
	/*
	Socket_connection s1;
	s1.listen_socket();
	while(!(connection_start==1))
	{	
		
		int stat=s1.return_accept_response();
		
		if (stat==1) 
		{	
			
						
			send(s1.return_accept_socket(), setup_msg , strlen(setup_msg) , 0 ); 

			SocketWrapper w1;
			w1.sender=inet_ntoa(s1.address.sin_addr);
			w1.receiver=getIPAddress();
			w1.socket_id=s1;
			w1.connect_num=findServerNum(string(inet_ntoa(s1.address.sin_addr)));
			pthread_mutex_lock(&list_lock);
			SocketConnectionListServer->push_back(w1);
			pthread_mutex_unlock(&list_lock);
			cout<<"Receiver - connected from "<<inet_ntoa(s1.address.sin_addr) <<" to "<<getIPAddress()<<endl;
			
			if (SocketConnectionListServer->size()==7)
				connection_start=1;
									
		}
		else
		{	
			cout<<"couldnt connect to the socket-receiver side"<<endl;
		
		}
		
		
	}
	*/	
	cout<<"************Connection completed*************"<<endl;	
	return 1;	

	
}
/*
//struct for exit
struct exit_app
{

	list <SocketWrapper> *SocketConnectionListServer;
};
//thread to close all the sockets and exit application 
void *exit_fn(void *threadarg)
{
	struct exit_app *data;
	data = (struct exit_app *) threadarg;
	int l;
	
	list <SocketWrapper> :: iterator itt;
	while(1)
	{
		if(exit_number)
		{
		
			cout<<"MESSAGE TRANSACTION STATS:"<<endl;
			cout<<"**************************"<<endl;
			cout<<"Total Number of Message Sent    ::"<<message_sent_count<<endl;
			cout<<"Total Number of Message Received::"<<message_received_count<<endl;
			cout<<"Number of Deadlock              ::"<<deadlock_count<<endl<<endl;		
			for(itt = (data->SocketConnectionListServer)->begin(); itt != (data->SocketConnectionListServer)->end(); ++itt) 
			{
				close(((*itt).socket_id).socket_fd);
				close(((*itt).socket_id).new_socket);
			}
			cout<<"SYSTEM EXIT"<<endl;
			exit(0);// force all thread to exit
		}
	}
}
//Algorithm to grant reply to this transaction
struct grant
{
	int socket;
	string serverName;
};
void *grantReply(void *threadarg)
{
	struct grant *data;
	data = (struct grant *) threadarg;	
	int valread;
	char buf[1024]={0};
	while(1)
	{
		valread = read(data->socket, buf, 1024); 
		string buffer(buf);
		pthread_mutex_lock(&message_received_count_lock);
		message_received_count++;
		pthread_mutex_unlock(&message_received_count_lock);
		size_t found0 = buffer.find("GRANT");
		size_t found1 = buffer.find("END");
		size_t found2 = buffer.find("start");
		if(valread && (found0 != string::npos))
		{				
			pthread_mutex_lock(&expected_grant_lock);
			expected_grant=expected_grant-1;
			pthread_mutex_unlock(&expected_grant_lock);
			cout<<"GRANT received from SERVER"<<findServerNum(data->serverName)<<" receive grant count "<<expected_grant<<endl;
		}
		else if(valread && (found1 != string::npos))
		{
			exit_number=1;
		}
		else if(valread && (found2 != string::npos))
		{
			start_transaction=1;
			cout<<"START message received"<<endl;
		}
		else
		{
			
			cout<<"received a junk message :"<<string(buf)<<" from SERVER"<<findServerNum(data->serverName)<<endl;
		}
	}

}
struct askQuorum
{
	int socket;
	string serverName;
	msec_t time;
};
void *askQuorumServer(void *threadarg)
{
	struct askQuorum *data;
	data = (struct askQuorum *) threadarg;
	char request[100]={0};
	int valread;
	snprintf( request, sizeof(request), "%s:%lu", "REQUEST",data->time);
	send(data->socket,&request , strlen(request) , 0);
	cout<<"REQUEST sent to SERVER "<<findServerNum(data->serverName)<<endl;
	pthread_mutex_lock(&message_sent_count_lock);
	message_sent_count++;
	pthread_mutex_unlock(&message_sent_count_lock);
}

struct Quorum_app
{
	list <SocketWrapper> *SocketConnectionListServer;
};
void *Quorum_transaction(void *threadarg)
{
	struct Quorum_app *data;
	data = (struct Quorum_app *) threadarg;
	cout<<"******START QUORUM TRANSCATION********"<<endl;
	list <SocketWrapper> :: iterator itt;
	//binary tree quorum
	int Quorum_array[15][4]=
	{
	{1,2,4,-1},
	{1,2,5,-1},
	{1,4,5,-1},
	{1,3,6,-1},
	{1,3,7,-1},
	{1,6,7,-1},	
	{2,4,3,6},
	{2,4,3,7},
	{2,5,3,6},
	{2,5,3,7},
	{2,4,6,7},
	{2,5,6,7},
	{4,5,3,6},
	{4,5,3,7},
	{4,5,6,7}
	};
	int select_Quorum;
	char finish_msg[100]={0};
	for(itt = (data->SocketConnectionListServer)->begin(); itt != (data->SocketConnectionListServer)->end(); ++itt) 
	{
		snprintf( finish_msg, sizeof(finish_msg), "%s", "start");
		send(((*itt).socket_id).return_accept_socket(), &finish_msg , strlen(finish_msg) , 0 );
	}
	
	for(int i=0;i<20;i++)
	{
		int sleep_time=rand()%5+5;
		cout<<"****************************************************"<<endl;
		cout<<"My Sleep time is "<<sleep_time<<" unit of time -iteration#"<<i+1<<endl;
		usleep(sleep_time*unit_delay);
		

		select_Quorum=rand()%15;
		if(select_Quorum<6)
		{
			expected_grant=3;
			cout<<"The chosen Quorum are:"<<Quorum_array[select_Quorum][0]<<Quorum_array[select_Quorum][1]<<Quorum_array[select_Quorum][2]<<endl;
		}
		else
		{
			expected_grant=4;
			cout<<"The chosen Quorum are:"<<Quorum_array[select_Quorum][0]<<Quorum_array[select_Quorum][1]<<Quorum_array[select_Quorum][2]<<Quorum_array[select_Quorum][3]<<endl;
		}
		msec_t now=time_ms();//take the first snapshot time
		pthread_t Request[4];
		struct askQuorum REQ[4];
		for(int j=0;j<4;j++)
		{
			if(Quorum_array[select_Quorum][j]==-1)
				continue;

			for(itt = (data->SocketConnectionListServer)->begin(); itt != (data->SocketConnectionListServer)->end(); ++itt) 
			{
				
				if(Quorum_array[select_Quorum][j]==(*itt).connect_num)
				{
					
					REQ[j].serverName=(*itt).sender;
					REQ[j].socket=((*itt).socket_id).return_accept_socket();
					REQ[j].time=now;
					int rc = pthread_create(&Request[j], NULL, askQuorumServer, (void *)&REQ[j]);
					if (rc)
					{
						cout<<"Problem with the creating Reply Thread.."<<endl;
							
					}
					break;
				}
			}
		
		}
		cout<<"waiting for all grant from Server Quorums"<<endl;
		while(expected_grant)
		{
			if(start_transaction)
			{
				cout<<"thread exit"<<endl;
				pthread_exit(0);
				break;		
			}		
		}
	
		cout<<"Entering the CRITICAL SECTION"<<endl;
		writeFile(now);
		usleep(3*unit_delay);//unit of time
		cout<<"Exiting CRITICAL SECTION"<<endl;
		for(int j=0;j<4;j++)
		{
			if(Quorum_array[select_Quorum][j]==-1)
				continue;

			for(itt = (data->SocketConnectionListServer)->begin(); itt != (data->SocketConnectionListServer)->end(); ++itt) 
			{
				if(Quorum_array[select_Quorum][j]==(*itt).connect_num)
				{
					char release[100]={0};
					snprintf( release, sizeof(release), "%s:%d", "RELEASE",Quorum_array[select_Quorum][j]);
					send(((*itt).socket_id).return_accept_socket(),&release , strlen(release) , 0);
					cout<<"RELEASE sent to SERVER"<<findServerNum((*itt).sender)<<endl;
					pthread_mutex_lock(&message_received_count_lock);
					message_sent_count++;
					pthread_mutex_unlock(&message_received_count_lock);
										
				}
			}
		
		}
	
	}
	for(itt = (data->SocketConnectionListServer)->begin(); itt != (data->SocketConnectionListServer)->end(); ++itt) 
	{
		char exit[100]={0};
		snprintf( exit, sizeof(exit), "%s", "END");
		send(((*itt).socket_id).return_accept_socket(),&exit , strlen(exit) , 0);
	}
	

}
int connectQuorum(list <SocketWrapper> *SocketConnectionListServer)
{
	list <SocketWrapper> :: iterator itt;
	 
	int server1_socket;
	int valread;
	pthread_t grant_reply[7];
	struct grant GRANT[7];
	int m;
	for(m=0,itt = SocketConnectionListServer->begin(); itt != SocketConnectionListServer->end(); ++itt,m++) 
	{
		GRANT[m].socket=((*itt).socket_id).return_accept_socket();
		GRANT[m].serverName=(*itt).sender;
		int rc = pthread_create(&grant_reply[m], NULL, grantReply, (void *)&GRANT[m]);
		if (rc)
		{
			cout<<"Problem with the creating Reply Thread.."<<endl;
		
		}
	}
	
	while(1)
	{
		if(start_transaction==1)
		{
			usleep(1000000);
			start_transaction=0;
			usleep(1000000);
			message_sent_count=0;
			message_received_count=0;
			if(deadlock_count>=0)
			{
				pthread_cancel(start_Quorum[deadlock_count]);
				cout<<"Force exiting the previous thread."<<endl;
			}
			deadlock_count++;
			expected_grant=4;
			
			struct Quorum_app q;
			q.SocketConnectionListServer=SocketConnectionListServer;
			int rc = pthread_create(&start_Quorum[deadlock_count], NULL, Quorum_transaction, (void *)&q);
			if (rc)
			{
				cout<<"Problem with the creating Reply Thread.."<<endl;
				return 0;	
			}
		}else if(start_transaction==-1)
		{
			break;
		}
	}
	
	while(1)
	{
	}
	

}
*/
int sendMessage(list <SocketWrapper> *SocketConnectionListServer)
{
	string Message="";
	char *write_Request="write";
	while(1)
	{
		cout<<"Type the Message to broadcast to Server:"<<endl;
		cin>>Message;
		if(strcmp(Message.c_str(),"phase")==0)
		{
			list <SocketWrapper> :: iterator itt;
			for(itt = SocketConnectionListServer->begin(); itt != SocketConnectionListServer->end(); ++itt) 
			{
				char phase_msg[100]={0};
				snprintf(phase_msg, sizeof(phase_msg), "%s", Message.c_str());
				send(((*itt).socket_id).socket_fd, &phase_msg , strlen(phase_msg) , 0 );
			}
		}
		else if(strcmp(Message.c_str(),"write")==0)
		{
			int server_num;
			string content;
			cout<<"Enter the Server number to send write:"<<endl;
			// send to the specific server
			cin>>server_num;
			//cout<<"Message to be written:"<<endl;			
			//cin>>content;
			list <SocketWrapper> :: iterator itt;
			for(itt = SocketConnectionListServer->begin(); itt != SocketConnectionListServer->end(); ++itt) 
			{
				if((*itt).connect_num==int(server_num))
				{
					char lock_Request_msg[1024]={0};
					//snprintf(lock_Request_msg, sizeof(lock_Request_msg), "%s:%s", write_Request,content.c_str());
					snprintf(lock_Request_msg, sizeof(lock_Request_msg), "write");
					send(((*itt).socket_id).socket_fd, &lock_Request_msg , strlen(lock_Request_msg) , 0 );
				}
			}
			
		}
		else if(strcmp(Message.c_str(),"end")==0)
		{
			list <SocketWrapper> :: iterator itt;
			for(itt = SocketConnectionListServer->begin(); itt != SocketConnectionListServer->end(); ++itt) 
			{
				
				char lock_Request_msg[1024]={0};
				snprintf(lock_Request_msg, sizeof(lock_Request_msg), "end");
				send(((*itt).socket_id).socket_fd, &lock_Request_msg , strlen(lock_Request_msg) , 0 );
				
			}
			cout<<"Transactions Ended"<<endl;
			cout<<"SYSTEM EXIT!"<<endl;
			sleep(2);
			exit(0);
			break; // need to send termination message.
		}
	}

}
///MAIN FUNCTION
int main()
{	
	
	//char* serverIPList[7]={SERVER1,SERVER2,SERVER3,SERVER4,SERVER5,SERVER6,SERVER7};
	//int N=5; //Total number of Clients
	//int client_num;
	//srand (time(NULL));
	//client_num=findClientNum(getIPAddress());
	list <SocketWrapper> SocketConnectionListServer;
	int status=makeConnection(&SocketConnectionListServer);
	if (status==0)
	{
		cout<<"problem with the connection"<<endl;
		return 0;
	}
	int stat=sendMessage(&SocketConnectionListServer);
	if (stat==0)
	{
		cout<<"problem with the sending connection"<<endl;
		return 0;
	}
	/*
	pthread_t exit_application;
	struct exit_app e;
	e.SocketConnectionListServer=&SocketConnectionListServer;
	int rc = pthread_create(&exit_application, NULL, exit_fn, (void *)&e);
	if (rc)
	{
		cout<<"Problem with the creating Reply Thread.."<<endl;
		return 0;	
	}
	
	
	int res=connectQuorum(&SocketConnectionListServer);
	if(res)
	{
		cout<<"problem with the server connection"<<endl;
		return 0;
	}
	*/	
	return 0;
}

///////////
////////////////////////////////////////////////
//
//
//      CS 6378 - PROJECT 3
//        VOTING ALGORITHM
//            SERVER
//         SUBMITTED BY
//   Jayaramaraja Balaramaraja(jxb162030)
//     Ayushi Chourasi(akc170630)
//
/////////////////////////////////////////////////
#include "connection.h"
using namespace std;
#define TRUE             1
#define FALSE            0
//global mutuex
pthread_mutex_t list_lock;
pthread_mutex_t resource_lock;
pthread_mutex_t LOCKED_lock;
pthread_mutex_t message_received_count_lock;
pthread_mutex_t message_sent_count_lock;
pthread_mutex_t exit_number_lock;
//global variables
bool LOCKED=FALSE;
int message_sent_count=0;
int message_received_count=0;
int deadlock_count=0;
int exit_number=5;
priority_queue <string, vector<string> ,greater<string> > QUEUE;
bool terminate_socket=TRUE;
bool close_flag=TRUE;
int VN=1;
int RU=8;
char DS='A';
bool LOCK_REQUEST=FALSE;
int M=0;
int waiting_reply=0;
bool Update_Success=FALSE;
bool Update_Flag=TRUE;
//struct to store the VN,RU and DS from answering servers
struct component
{
int RU;
int VN;
char DS;
};
list <component> set_I;

//Function
//Grab the IP Address of the current machine
string getIPAddress()
{
    	string ipAddress="Unable to get IP Address";
    	struct ifaddrs *interfaces = NULL;
    	struct ifaddrs *temp_addr = NULL;
    	int success = 0;
    
    	success = getifaddrs(&interfaces);
    	if (success == 0) 
	{
        
        	temp_addr = interfaces;
        	while(temp_addr != NULL) 
		{
            		if(temp_addr->ifa_addr->sa_family == AF_INET) 
			{
                
                		if(strcmp(temp_addr->ifa_name, "en0"))
				{
                    			ipAddress=inet_ntoa(((struct sockaddr_in*)temp_addr->ifa_addr)->sin_addr);
                		}
            		}
            	temp_addr = temp_addr->ifa_next;
        	}
    	}
   
    	freeifaddrs(interfaces);
    	return ipAddress;
}
///Creating a class to deal with lower socket 
class Socket_connection
{
public:
	int socket_fd, new_socket, valread; 
	struct sockaddr_in address; 
	int opt = 1; 
	int addrlen = sizeof(address); 
	int iMode=0;
	Socket_connection()
	{
		// Creating socket file descriptor 
		if ((socket_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) 
		{ 
			perror("socket failed"); 
			exit(EXIT_FAILURE); 
		} 
		bzero((char *) &address, sizeof(address));
		ioctl(socket_fd, FIONBIO, &iMode); 
		address.sin_port = htons(PORT);
		address.sin_family = AF_INET;
		 
	}
	Socket_connection(const Socket_connection &sock)  //copy constructor
	{
		socket_fd=sock.socket_fd;
		new_socket=sock.new_socket; 
		valread=sock.valread;
		address=sock.address; 
		opt=1;
		addrlen =sock.addrlen;
		iMode=0;

	}
	~Socket_connection()  //destructor
	{
	
	}
	int connect_socket(char* IPname)
	{	
		
		
		if(inet_pton(AF_INET, IPname, &address.sin_addr)<=0)  
    		{ 
        		cout<<"Invalid address/ Address not supported "<<endl; 
        		return 0; 
    		}		
		
		if(connect(socket_fd, (struct sockaddr *)&address, sizeof(address))<0) 
		{
			cout<<"Connection Failed "<<endl; 
        		return 0;
		}
		else
		{
			return 1;
		}
		
		
		
    		
	}
	int listen_socket()
	{	
		
		// Forcefully attaching socket to the port 2408 
		if (setsockopt(socket_fd, SOL_SOCKET, (SO_REUSEPORT | SO_REUSEADDR),&opt, sizeof(opt))) 
		{ 
		perror("setsockopt"); 
		exit(EXIT_FAILURE); 
		} 
		address.sin_addr.s_addr = INADDR_ANY; 
		
		// Forcefully attaching socket to the port 8080 
		if (bind(socket_fd, (struct sockaddr *)&address, sizeof(address))<0) 
		{ 
		perror("bind failed"); 
		return 0; 
		} 
		
		if (listen(socket_fd, 32) < 0) 
		{ 
		perror("listen failed"); 
		return 0; 
		} 
		
	}
	int return_accept_response()
	{
		cout<<"waiting to connect here"<<endl;
		if ((new_socket = accept(socket_fd, (struct sockaddr *)&address,(socklen_t*)&addrlen))<0) 
		{ 
		perror("accept failed"); 
		return 0; 
		} 
		else
		{
			return 1;
		}
		
	}
	int return_accept_socket()
	{
		return new_socket;
	}
	
			
};

//Creating a wrapper for the socket with sender and receiver information
class SocketWrapper
{
public:
	string sender;
	string receiver;
	Socket_connection socket_id;
	int connect_num;
	SocketWrapper()
	{
		sender="";
		receiver="";

	}
	SocketWrapper(const SocketWrapper &wrap)//copy constructor
	{
		sender=wrap.sender;
		receiver=wrap.receiver;
		socket_id=wrap.socket_id;
		connect_num=wrap.connect_num;

	}
	~SocketWrapper()//destructor
	{
	}
	
};

///Function
//to read all the files present in the directory
string read_directory(char* name)
{
		
	char files[200];
	DIR* dirp = opendir(name);
	list<string> filesList;
	struct dirent * dp;
	
	while ((dp = readdir(dirp)) != NULL) 
	{
	
		if(strcmp(dp->d_name,".")==0 || strcmp(dp->d_name,"..")==0 || string(dp->d_name).back()=='~')
			continue;
		
		filesList.push_back(dp->d_name);
		
	}
	closedir(dirp);
	filesList.sort();
	list<string>::iterator it2;

	
	for (it2 = filesList.begin(); it2 != filesList.end(); it2++)
	{  	
		strcat(files,(*it2).c_str());
		strncat(files,",",sizeof(","));
	}
	return string(files);
}
//find the server number
int findServerNum(string IP)
{
	char* serverIPList[8]={A,B,C,D,E,F,G,H};	
	int N=8; //Total number of Servers
	int server_num=10;
	for(int i=0;i<N;i++)// find the client number
	{
		if(IP==string(serverIPList[i]))
		{
			server_num=i;
			break;	
		}
	}
	return server_num;
}

//Reading the phase of connection and disconnection
// This function creates a bit mask to show connection to send as (1) and nodes to disconnect as (-1)
int readConfigure(int phase_num,int server_num,int makeConnect[8])
{
	char* serverIPList[8]={A,B,C,D,E,F,G,H};
	std::ifstream f("Configure_Connection.txt");
	string s;
	string server_letter="ABCDEFGH-";
	int flag=0;
	int end_file=0; 
	int count=0;
	list<char> fromConnect;
	for (int i = 1; i <= phase_num; i++)
	{	
		try
		{
        		std::getline(f, s);
		}
		catch(...)
		{
			return 1;
		}
	}
	cout<<s<<endl;
	for(int j=0;j<s.length();j++)
	{
		if(s[j]==':')
		{
			if(flag==1)
				break;
			else
			{
			 	fromConnect.clear();
			}
		}
		if(server_letter[server_num]==s[j])
		{
			flag=1;
			
			continue;
		}
		else if(flag!=1)
		{
			fromConnect.push_back(s[j]);
		}
		if(flag==1 && s[j]!=':')
		{
			size_t found0 = server_letter.find(s[j]);
			if(found0 != string::npos)
			{
				makeConnect[found0]=1;
			}
			
		}
		
		
	}
	list<char>::iterator it;
	int l;
	for (l=0,it=fromConnect.begin(); it!=fromConnect.end(); ++it,l++)
	{
		size_t found0 = server_letter.find((*it));
		if(found0 != string::npos)
		{
    			makeConnect[found0]=0;
		}
		
	}
	return end_file;
}


//function to append the string to the file
void writeFile(char* filename,string appendText)
{

  	std::ofstream outfile;

  	outfile.open(filename, std::ios_base::app);
  	outfile << appendText<<endl;;


}
//function to get the last line from the file
string getLastLine(char* filename)
{
	std::string lastline;
	std::ifstream fs;
	fs.open(filename, std::fstream::in);
	if(fs.is_open())
	{
		//Got to the last character before EOF
		fs.seekg(-1, std::ios_base::end);
		if(fs.peek() == '\n')
		{
			//Start searching for \n occurrences
			fs.seekg(-1, std::ios_base::cur);
			int i = fs.tellg();
			for(i;i > 0; i--)
			{
				if(fs.peek() == '\n')
				{
 					 //Found
  					fs.get();
  					break;
				}		
				//Move one character back
				fs.seekg(i, std::ios_base::beg);
			}
		}

		getline(fs, lastline);
		std::cout << lastline << std::endl;
	}
	else
	{
		std::cout << "Could not find end line character" << std::endl;
		lastline="no content";
	}	
	return lastline;
}
//read thread struct
struct read_app
{
		list <SocketWrapper> *SocketConnectionList; // gives the number of components connected
		int socket_id;
		int connect_num;
		
};
//Read thread that connects to specific servers socket
void *readThreadFunction(void *threadarg)
{
	struct read_app *data;
	data = (struct read_app *) threadarg;
	char *close_msg="close";
	cout<<"Read Thread connected to SERVER"<<(char)('A'+data->connect_num)<<" with socket_id:"<<data->socket_id<<endl;
	
	while(1)
	{
		char buf[1024]={0};
		int valread1;
		valread1 = read(data->socket_id  , buf, 1024); 
		cout<<string(buf)<<endl;
		string buffer(buf);
		
		size_t found0 = buffer.find("LOCK_REQUEST");
		size_t found1 = buffer.find("VOTE_REQUEST");
		size_t found2 = buffer.find("COMMIT");
		size_t found3 = buffer.find("ABORT");
		std::string delimiter = ":";
		if(valread1 && (strcmp(buf, "close") == 0))
		{
			break;
		}
		else if(valread1 && (found0 != string::npos))
		{
			
			if (!LOCK_REQUEST)
			{
				list <SocketWrapper> :: iterator it1;
				char fileStatus[100]={0};
				snprintf( fileStatus, sizeof(fileStatus), "VOTE_REQUEST:%d :%d :%c",VN,RU,DS);
				send(data->socket_id, fileStatus , strlen(fileStatus) , 0 );
				LOCK_REQUEST=TRUE;
			}
		}
		else if(valread1 && (found1 != string::npos))
		{
			if(LOCK_REQUEST)
			{
				int RU_final;
				char DS_final;
				waiting_reply--; //received a  reply
				
				size_t pos = 0;
				std::string token;
				pos = buffer.find(":");
				token = buffer.substr(0, buffer.find(":"));
				buffer.erase(0, pos + delimiter.length());

				pos = buffer.find(":");
				token = buffer.substr(0, buffer.find(":"));
				int temp_VN=stoi(token); //string might fail
				if(M<temp_VN)
					M=temp_VN;
				buffer.erase(0, pos + delimiter.length());
				
				pos = buffer.find(":");
				token = buffer.substr(0, buffer.find(":"));
				int temp_RU=stoi(token);
				buffer.erase(0, pos + delimiter.length());
				
				
				pos = buffer.find(":");
				token = buffer.substr(0, buffer.find(":"));
				
				char temp_DS=token[token.size()-1];
				component c;
				c.VN=temp_VN;
				c.RU=temp_RU;
				c.DS=temp_DS;
				set_I.push_back(c);
				
				cout<<"Status of SERVER:"<<(char)('A'+data->connect_num)<<" VN:"<<temp_VN<<" RU:"<<temp_RU<<" DS:"<<temp_DS<<endl;
				while(waiting_reply!=0)  // wait for all the reply of VN
				{
				}
				if(Update_Flag)
				{
					Update_Flag=FALSE;
					list <component> ::iterator m;
					for( m = set_I.begin(); m != set_I.end(); ++m) 
					{
						if((*m).VN==M)
						{
							RU_final=temp_RU;
						}
					}
					
					if(RU_final/2<(data->SocketConnectionList)->size())
					{
						Update_Success=TRUE;
						//temp_success=TRUE;	
					
					}
					else if(RU_final/2==(data->SocketConnectionList)->size())
					{
						int check_DS=DS-'A';
						list <SocketWrapper> :: iterator it1;
						for( it1 = (data->SocketConnectionList)->begin(); it1 != (data->SocketConnectionList)->end(); ++it1) 
						{
							if((*it1).connect_num==check_DS)
							{
							Update_Success=TRUE;
							break;
							}
						}					
					
					}
					else
					{
						Update_Success=FALSE;
					}
				
					if(Update_Success)
					{
					
										
						VN=M;
						VN++;
						RU=(data->SocketConnectionList)->size();
						int DS_low=8;
						list <SocketWrapper> :: iterator it1;
						for( it1 = (data->SocketConnectionList)->begin(); it1 != (data->SocketConnectionList)->end(); ++it1) 
						{
							if((*it1).connect_num<DS_low)
							{
								DS_low=(*it1).connect_num;
							}
						}
						if(findServerNum(getIPAddress())<DS_low)
						{
							DS_low=findServerNum(getIPAddress());
						}
						if((data->SocketConnectionList)->size()%2==0)
						{
							DS='A'+ DS_low;
						}
						for( it1 = (data->SocketConnectionList)->begin(); it1 != (data->SocketConnectionList)->end(); ++it1) 
						{
							if((*it1).connect_num!=10 || (*it1).connect_num!=findServerNum(getIPAddress()))
							{
								char fileStatus[100]={0};
								snprintf( fileStatus, sizeof(fileStatus), "COMMIT:%d :%d :%c",VN,RU,DS);
								if((*it1).receiver==getIPAddress())
								{
									 send((*it1).socket_id.return_accept_socket(), fileStatus , strlen(fileStatus) , 0 );
							
								}
								else
								{
									send((*it1).socket_id.socket_fd, fileStatus , strlen(fileStatus) , 0 );
								
								}
				
							}
						}
						cout<<"********************************************"<<endl;
						cout<<"Status::VN="<<VN<<", RU="<<RU<<", DS="<<DS<<endl;
						cout<<"********************************************"<<endl;
						cout<<"VN updated"<<endl;
					
					}
					else
					{
					
					
						list <SocketWrapper> :: iterator it1;
						for( it1 = (data->SocketConnectionList)->begin(); it1 != (data->SocketConnectionList)->end(); ++it1) 
						{
							if((*it1).connect_num!=10 || (*it1).connect_num!=findServerNum(getIPAddress()))
							{
								char fileStatus[100]={0};
								snprintf( fileStatus, sizeof(fileStatus), "ABORT");
								if((*it1).receiver==getIPAddress())
								{
									 send((*it1).socket_id.return_accept_socket(), fileStatus , strlen(fileStatus) , 0 );
							
								}
								else
								{
									send((*it1).socket_id.socket_fd, fileStatus , strlen(fileStatus) , 0 );
								
								}
				
							}
						}
						cout<<"********************************************"<<endl;
						cout<<"Status::VN="<<VN<<", RU="<<RU<<", DS="<<DS<<endl;
						cout<<"********************************************"<<endl;
				 		cout<<"write aborted"<<endl;
					
					}
				//Update for sucess
				set_I.clear();
				LOCK_REQUEST=FALSE;
				}
			}
		}
		else if(valread1 && (found2 != string::npos))
		{
			if(LOCK_REQUEST)
			{
				size_t pos = 0;
				std::string token;
				pos = buffer.find(":");
				token = buffer.substr(0, buffer.find(":"));
				buffer.erase(0, pos + delimiter.length());
		
				pos = buffer.find(":");
				token = buffer.substr(0, buffer.find(":"));
				VN=stoi(token); //string might fail
				buffer.erase(0, pos + delimiter.length());

				pos = buffer.find(":");
				token = buffer.substr(0, buffer.find(":"));
				RU=stoi(token);
				buffer.erase(0, pos + delimiter.length());

				pos = buffer.find(":");
				token = buffer.substr(0, buffer.find(":"));
				
				DS=token[token.size()-1];
				cout<<"********************************************"<<endl;
				cout<<"Status::VN="<<VN<<", RU="<<RU<<", DS="<<DS<<endl;
				cout<<"********************************************"<<endl;
				cout<<"Write Success!"<<endl;
				LOCK_REQUEST=FALSE;
				Update_Flag=TRUE;
			}
		}
		else if(valread1 && (found3 != string::npos))
		{
			if(LOCK_REQUEST)
			{
				cout<<"Write Failed!"<<endl;
				LOCK_REQUEST=FALSE;
				Update_Flag=TRUE;
			}
		}
		
	}
	cout<<"READ Thread exit - disconnected to SERVER:"<<(char)('A'+data->connect_num)<<endl;
}

//listen thread Struct
struct listenThreadStruct
{
	list <SocketWrapper> *SocketConnectionList;
};
//Declaring globally
// The thread cant resuse the namespace - as it creates pointer reference problem hence array of thread are created
// with thread index taking with specific server number
pthread_t readThreadApplication[8];
struct read_app R[8];


// This thread always listen in the port 2408 and updates the list
void *listenThread(void *threadarg)
{
	struct listenThreadStruct *data;
	data = (struct listenThreadStruct *) threadarg;
	cout<<"Listen Thread Started"<<endl;
	char *setup_msg = "received";
	
	while(terminate_socket)
	{
		Socket_connection s1;
		s1.listen_socket();
		while(1)
		{	
			int stat=s1.return_accept_response();
			if (stat==1) 
			{	
			
				send(s1.return_accept_socket(), setup_msg , strlen(setup_msg) , 0 ); 
				SocketWrapper w1;
				w1.sender=inet_ntoa(s1.address.sin_addr);
				w1.receiver=getIPAddress();
				w1.socket_id=s1;
				if(string(inet_ntoa(s1.address.sin_addr))==con)
				{
					w1.connect_num=10;
				}
				else
				{
					w1.connect_num=findServerNum(string(inet_ntoa(s1.address.sin_addr)));
				}
				
				(data->SocketConnectionList)->push_back(w1);
				
				cout<<"Receiver - connected from SERVER "<<findServerNum(inet_ntoa(s1.address.sin_addr)) <<" to SERVER "<<findServerNum(getIPAddress())<<endl;
				//read thread created after adding in list
				if(w1.connect_num!=10)
				{
					
					
					R[w1.connect_num].connect_num=findServerNum(string(inet_ntoa(s1.address.sin_addr)));//(*iterator1).connect_num;
					R[w1.connect_num].socket_id=s1.return_accept_socket();
					R[w1.connect_num].SocketConnectionList=data->SocketConnectionList;
					int rc = pthread_create(&readThreadApplication[w1.connect_num], NULL, readThreadFunction, (void *)&R[w1.connect_num]);
					if (rc)
					{
						cout<<"Problem with the creating exit thread.."<<endl;
						return 0;	
					}
				}					
			}
			else
			{	
				cout<<"couldnt connect to the socket-receiver side"<<endl;
		
			}
		
		
		}
		close_flag=TRUE;
	}


}



// Make connection.. Server waits to connect to all threads
int makeConnection(list <SocketWrapper> *SocketConnectionList)
{	
	cout<<"Main Client Thread created"<<endl;
	int phase=4;//number of stage... this has to be entered manually... it is the length of the configure file
	char* serverIPList[8]={A,B,C,D,E,F,G,H};
	int connection_start=0,status,client_num,flag=0;
	char *setup_msg = "received";
	char *close_msg ="close";
	int valread=0;
	int server_num;
	server_num=findServerNum(getIPAddress());
	cout<<"I am a Server no:"<<(char)('A'+server_num) <<" and My Ip address is::"<<getIPAddress()<<endl;
	
	//creating the generic listen thread that listens in the PORT 2408 and push the socket to the List.
	pthread_t listen_application;
	struct listenThreadStruct l;
	l.SocketConnectionList=SocketConnectionList;
	int rc = pthread_create(&listen_application, NULL, listenThread, (void *)&l);
	if (rc)
	{
		cout<<"Problem with the creating listen thread.."<<endl;
		return 0;	
	}


	int phase_num=0;
	
	while(1)
	{

		string Phase_Shift;
			
		char Controller_msg[1024]={0};
		list <SocketWrapper> :: iterator it1;
		
		for( it1 = SocketConnectionList->begin(); it1 != SocketConnectionList->end(); ++it1) 
		{
			if((*it1).connect_num==10)
			{
				valread = read((*it1).socket_id.return_accept_socket(), Controller_msg, 1024); 
				break;
			}
		}
		string Controller_buffer(Controller_msg);
		size_t found0 = Controller_buffer.find("write");
		std::string delimiter = ":";
		if(strcmp(Controller_msg,"phase")==0 && valread)
		{
			if(phase_num>5)// 5 is the number of lines in the configure text
			{	
				cout<<"Exiting beacuse configure file ended"<<endl;
				break;
			}
			int makeConnect[8]={-1,-1,-1,-1,-1,-1,-1,-1};
			phase_num=phase_num+1;
			int end_file=readConfigure(phase_num,server_num,makeConnect);
			if(end_file)
			{
				cout<<"Config File Ended"<<endl;
				break;
			}
			cout<<"*********************************"<<endl;
			cout<<"ITERATION PHASE::"<<phase_num<<endl;
			cout<<"*********************************"<<endl;
			for(int i=0;i<8;i++)
			{
				cout<<makeConnect[i];
			}
			cout<<endl;
			for(int i=0;i<8;i++)
			{
				if(makeConnect[i]==-1)
				{
					list <SocketWrapper> :: iterator it;	
					for(it = SocketConnectionList->begin(); it != SocketConnectionList->end(); ++it) 
					{
						if((*it).connect_num==i)
						{
							if((*it).receiver==getIPAddress())
							{
								send((*it).socket_id.return_accept_socket(), close_msg , strlen(close_msg) , 0 ); 
								shutdown((*it).socket_id.return_accept_socket(),3);
								close((*it).socket_id.return_accept_socket());
							
							}
							else
							{
								send((*it).socket_id.socket_fd, close_msg , strlen(close_msg) , 0);
								shutdown((*it).socket_id.socket_fd,3);
								close((*it).socket_id.socket_fd);
							}		
							cout<<"Removing the node SERVER:"<< (char)('A'+findServerNum((*it).sender))<<" connected to SERVER:"<<(char)('A'+findServerNum((*it).receiver))<<endl;
							it=SocketConnectionList->erase(it);
							break;
						}
			
					}
				}
			}
			cout<<endl;
			int skip;
			

			for(int i=0;i<8;i++)
			{
				skip=0;
				if(makeConnect[i]==1)
				{
					list <SocketWrapper> :: iterator itt;
					int l;
					for(l=0, itt = SocketConnectionList->begin(); itt != SocketConnectionList->end(); ++itt,l++) 
					{
						if((*itt).sender==string(serverIPList[i]) || (*itt).receiver==string(serverIPList[i]))
						{
							skip=1;
							break;
						}
					}
					if (skip==1)
					{
						continue;
					}
					
					Socket_connection s1; //created for the sender clients
					SocketWrapper w1;
					w1.sender=getIPAddress();
					w1.receiver=serverIPList[i];
					w1.connect_num=findServerNum(string(serverIPList[i]));
					//connecting other servers
					int stat=s1.connect_socket(serverIPList[i]);
					w1.socket_id=s1;
					if (stat==1)
					{	
						
						char buf[1024]={0};
						int valread1;
						valread1 = read(s1.socket_fd  , buf, 1024); 
						
						if(valread1 && (strcmp(buf, "received") == 0))
						{
							
							SocketConnectionList->push_back(w1); //need mutex here
							cout<<"Sender - connected SERVER:"<< (char)('A'+findServerNum(w1.sender)) <<" to SERVER:"<< (char)('A'+findServerNum(w1.receiver)) <<endl;
						}
					}
					else
					{
						cout<<"error in sending the client connect.."<<endl;
		
					}
					
					R[w1.connect_num].connect_num=i;
					R[w1.connect_num].socket_id=s1.socket_fd;
					R[w1.connect_num].SocketConnectionList=SocketConnectionList;
					int rc = pthread_create(&readThreadApplication[w1.connect_num], NULL, readThreadFunction, (void *)&R[w1.connect_num]);
					if (rc)
					{
						cout<<"Problem with the creating exit thread.."<<endl;
						return 0;	
					}		
				
				}
				
			}
			
					
		}
		else if((found0 != string::npos) && valread)
		{
			cout<<"Initiate the Write Sequence"<<endl;
			if(SocketConnectionList->size()==1)
			{
				cout<<"********************************************"<<endl;
				cout<<"Status::VN="<<VN<<", RU="<<RU<<", DS="<<DS<<endl;
				cout<<"********************************************"<<endl;
				cout<<"Write Aborted"<<endl;
			}
			else
			{
				LOCK_REQUEST=TRUE;
				Update_Success=FALSE;
				Update_Flag=TRUE;
				waiting_reply=SocketConnectionList->size()-1;
				
				list <SocketWrapper> :: iterator iterator1;
				int s;
				for(s=0, iterator1 = SocketConnectionList->begin(); iterator1 != SocketConnectionList->end(); ++iterator1,s++) 
				{
					if((*iterator1).connect_num!=10)
					{
						char fileStatus[100]={0};
						snprintf( fileStatus, sizeof(fileStatus), "LOCK_REQUEST");
						if((*iterator1).sender==getIPAddress())
						{
							send((*iterator1).socket_id.socket_fd, fileStatus , strlen(fileStatus) , 0 );
							cout<<"LOCK_REQUEST sent to SERVER"<<findServerNum((*iterator1).receiver)<<endl;
						}
						else
						{
							send((*iterator1).socket_id.return_accept_socket(), fileStatus , strlen(fileStatus) , 0 );
							cout<<"LOCK_REQUEST sent to SERVER"<<findServerNum((*iterator1).sender)<<endl;
						}
					}
				}
			}
			
		}
		else if(strcmp(Controller_msg,"end")==0  && valread)
		{
			cout<<"End the Transactions"<<endl;
			cout<<"SYSTEM EXIT"<<endl;
			exit(0);
			break;
		}
		
		
	}	


	cout<<"Connection completed"<<endl;	
}



//Main Function
int main()
{	
	list <SocketWrapper> SocketConnectionList;
	int status=makeConnection(&SocketConnectionList);
	if(status==0)
	{
		cout<<"Problem with connection/disconnection setup.."<<endl;
		return 1;	
	}

	cout<<"Back to Main Connection"<<endl;
	while(1)
	{
	}
		
	return 0;
}
/////
////////////////////////////////////////////////
//
//
//      CS 6378 - PROJECT 3
//         VOTING ALGORITHM
//          Controller
//         SUBMITTED BY
//    Ayushi Chourasi(akc170630)
//  Jayaramaraja Balaramaraja(jxb162030)
//
/////////////////////////////////////////////////
#include "connection.h"

using namespace std;

#define TRUE             1
#define FALSE            0
typedef int64_t msec_t;
//Global mutex for receiving threads
pthread_mutex_t list_lock;
pthread_mutex_t server_list_lock;
pthread_mutex_t struct_lock;
pthread_mutex_t Id_thread_lock;
pthread_mutex_t expected_grant_lock;
pthread_mutex_t message_received_count_lock;
pthread_mutex_t message_sent_count_lock;
//Global variable for thread control
int Id_thread=0;
int connect_complete=0; 
int expected_grant=4;
int start_transaction=0;
int unit_delay=100000;//100 miliseconds
int message_sent_count=0;
int message_received_count=0;
int deadlock_count=-1;
bool exit_number=0;
pthread_t start_Quorum[30];
//Grab the IP Address of the current machine
string getIPAddress()
{
    	string ipAddress="Unable to get IP Address";
    	struct ifaddrs *interfaces = NULL;
    	struct ifaddrs *temp_addr = NULL;
    	int success = 0;
    
    	success = getifaddrs(&interfaces);
    	if (success == 0) 
	{
        
        	temp_addr = interfaces;
        	while(temp_addr != NULL) 
		{
            		if(temp_addr->ifa_addr->sa_family == AF_INET) 
			{
                
                		if(strcmp(temp_addr->ifa_name, "en0"))
				{
                    			ipAddress=inet_ntoa(((struct sockaddr_in*)temp_addr->ifa_addr)->sin_addr);
                		}
            		}
            	temp_addr = temp_addr->ifa_next;
        	}
    	}
   
    	freeifaddrs(interfaces);
    	return ipAddress;
}

msec_t time_ms(void)
{
    struct timeval tv;
    gettimeofday(&tv, NULL);
    return (msec_t)tv.tv_sec * 1000 + tv.tv_usec / 1000;
}
///Creating a class to deal with lower socket 
class Socket_connection
{
public:
	int socket_fd, new_socket, valread; 
	struct sockaddr_in address; 
	int opt = 1; 
	int addrlen = sizeof(address); 
	int iMode=0;
	Socket_connection()
	{
		// Creating socket file descriptor 
		if ((socket_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) 
		{ 
			perror("socket failed"); 
			exit(EXIT_FAILURE); 
		} 
		bzero((char *) &address, sizeof(address));
		ioctl(socket_fd, FIONBIO, &iMode); 
		address.sin_port = htons( PORT );
		address.sin_family = AF_INET;
		 
	}
	Socket_connection(const Socket_connection &sock)  //copy constructor
	{
	socket_fd=sock.socket_fd;
	new_socket=sock.new_socket; 
	valread=sock.valread;
	address=sock.address; 
	opt=1;
	addrlen =sock.addrlen;
	iMode=0;

	}
	~Socket_connection()  //destructor
	{
	
	}
	int connect_socket(char* IPname)
	{	
		
		
		if(inet_pton(AF_INET, IPname, &address.sin_addr)<=0)  
    		{ 
        		cout<<"Invalid address/ Address not supported "<<endl; 
        		return 0; 
    		}		
		
		if(connect(socket_fd, (struct sockaddr *)&address, sizeof(address))<0) 
		{
			cout<<"Connection Failed "<<endl; 
        		return 0;
		}
		else
		{
			return 1;
		}
		
		
		
    		
	}
	int listen_socket()
	{	
		
		// Forcefully attaching socket to the port 2408 
		if (setsockopt(socket_fd, SOL_SOCKET, (SO_REUSEPORT | SO_REUSEADDR),&opt, sizeof(opt))) 
		{ 
		perror("setsockopt"); 
		exit(EXIT_FAILURE); 
		} 
		address.sin_addr.s_addr = INADDR_ANY; 
		
		// Forcefully attaching socket to the port 8080 
		if (bind(socket_fd, (struct sockaddr *)&address, sizeof(address))<0) 
		{ 
		perror("bind failed"); 
		return 0; 
		} 
		
		if (listen(socket_fd, 32) < 0) 
		{ 
		perror("listen failed"); 
		return 0; 
		} 
		
	}
	int return_accept_response()
	{
		
		if ((new_socket = accept(socket_fd, (struct sockaddr *)&address,(socklen_t*)&addrlen))<0) 
		{ 
		perror("accept failed"); 
		return 0; 
		} 
		else
		{
			return 1;
		}
		
	}
	int return_accept_socket()
	{
		return new_socket;
	}
	
			
};

//Creating a wrapper for the socket with sender and receiver information
class SocketWrapper
{
public:
	string sender;
	string receiver;
	Socket_connection socket_id;
	int connect_num;
	SocketWrapper()
	{
		sender="";
		receiver="";

	}
	SocketWrapper(const SocketWrapper &wrap)//copy constructor
	{
		sender=wrap.sender;
		receiver=wrap.receiver;
		socket_id=wrap.socket_id;
		connect_num=wrap.connect_num;

	}
	~SocketWrapper()//destructor
	{
	}
	
};

//find the server number
int findServerNum(string IP)
{
	char* serverIPList[8]={A,B,C,D,E,F,G,H};	
	int N=8; //Total number of Clients
	int server_num=0;
	for(int i=0;i<N;i++)// find the client number
	{
		if(IP==string(serverIPList[i]))
		{
			server_num=i;
			break;	
		}
	}
	return server_num;
}

//Main function to trigger connection to other clients and Servers in thread
int makeConnection(list <SocketWrapper> *SocketConnectionListServer)
{	
	cout<<"Main Client Thread created"<<endl;
	int value;
	char* serverIPList[8]={A,B,C,D,E,F,G,H};
	int valread;
	int connection_start=0,status,client_num,flag=0,rc;
	char *setup_msg = "received";
	cout<<"I am an server controller and My Ip address is::"<<getIPAddress()<<endl;
	cout<<"Type 1 to start connection:"<<endl;	
	cin>>value;
	while(1)
	{
		if(value==1)
		{
			for(int i=0;i<8;i++)
			{
				Socket_connection s1; //created for the sender clients
				SocketWrapper w1;
				w1.sender=getIPAddress();
				w1.receiver=serverIPList[i];
				w1.connect_num=findServerNum(string(serverIPList[i]));
				//connecting other servers
				int stat=s1.connect_socket(serverIPList[i]);
				w1.socket_id=s1;
				if (stat==1)
				{	

					char buf[1024]={0};
					valread = read(s1.socket_fd  , buf, 1024); 
					if(valread && (strcmp(buf, "received") == 0))
					{
						pthread_mutex_lock(&list_lock);
						SocketConnectionListServer->push_back(w1); //need mutex here
						pthread_mutex_unlock(&list_lock);
						cout<<"Sender - connected "<< w1.sender <<" to "<< w1.receiver <<endl;
					}
				}
				else
				{
					cout<<"error in sending the client connect.."<<endl;

				}
			}
			break;
		}
		else
		{
			cout<<"Please Enter 1 to start connection"<<endl;
		}
	}
		
	cout<<"************Connection completed*************"<<endl;	
	return 1;	

	
}

int sendMessage(list <SocketWrapper> *SocketConnectionListServer)
{
	string Message="";
	char *write_Request="write";
	while(1)
	{
		cout<<"Type the Message to broadcast to Server:"<<endl;
		cin>>Message;
		if(strcmp(Message.c_str(),"phase")==0)
		{
			list <SocketWrapper> :: iterator itt;
			for(itt = SocketConnectionListServer->begin(); itt != SocketConnectionListServer->end(); ++itt) 
			{
				char phase_msg[100]={0};
				snprintf(phase_msg, sizeof(phase_msg), "%s", Message.c_str());
				send(((*itt).socket_id).socket_fd, &phase_msg , strlen(phase_msg) , 0 );
			}
		}
		else if(strcmp(Message.c_str(),"write")==0)
		{
			int server_num;
			string content;
			cout<<"Enter the Server number to send write:"<<endl;
			// send to the specific server
			cin>>server_num;
			list <SocketWrapper> :: iterator itt;
			for(itt = SocketConnectionListServer->begin(); itt != SocketConnectionListServer->end(); ++itt) 
			{
				if((*itt).connect_num==int(server_num))
				{
					char lock_Request_msg[1024]={0};
					snprintf(lock_Request_msg, sizeof(lock_Request_msg), "write");
					send(((*itt).socket_id).socket_fd, &lock_Request_msg , strlen(lock_Request_msg) , 0 );
				}
			}
			
		}
		else if(strcmp(Message.c_str(),"end")==0)
		{
			list <SocketWrapper> :: iterator itt;
			for(itt = SocketConnectionListServer->begin(); itt != SocketConnectionListServer->end(); ++itt) 
			{
				
				char lock_Request_msg[1024]={0};
				snprintf(lock_Request_msg, sizeof(lock_Request_msg), "end");
				send(((*itt).socket_id).socket_fd, &lock_Request_msg , strlen(lock_Request_msg) , 0 );
				
			}
			cout<<"Transactions Ended"<<endl;
			cout<<"SYSTEM EXIT!"<<endl;
			sleep(2);
			exit(0);
			break; // need to send termination message.
		}
	}

}
///MAIN FUNCTION
int main()
{	
	
	list <SocketWrapper> SocketConnectionListServer;
	int status=makeConnection(&SocketConnectionListServer);
	if (status==0)
	{
		cout<<"problem with the connection"<<endl;
		return 0;
	}
	int stat=sendMessage(&SocketConnectionListServer);
	if (stat==0)
	{
		cout<<"problem with the sending connection"<<endl;
		return 0;
	}
	
	return 0;
}
